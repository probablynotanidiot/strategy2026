<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FRC REEFSCAPE 2025 Scouting (Tables Only)</title>
<style>
  :root{
    --bg:#0b0f14; --card:#111722; --muted:#98a2b3; --text:#e6edf3; --accent:#2e7dd7; --accent2:#00b894; --warn:#ffd166;
    --border:#1f2a3a;
  }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji"; 
       background:var(--bg); color:var(--text); margin:0; padding:24px;}
  h1,h2{margin:12px 0 8px}
  small, .muted{color:var(--muted)}
  .row{display:flex; gap:16px; flex-wrap:wrap}
  .card{background:var(--card); border:1px solid var(--border); border-radius:12px; padding:14px; flex:1 1 420px; min-width:360px}
  table{width:100%; border-collapse:collapse; font-size:13px; border:1px solid var(--border); background:#0f1520}
  thead th{position:sticky; top:0; background:#0e1522; z-index:1}
  th, td{border-bottom:1px solid var(--border); padding:6px 8px; text-align:left; vertical-align:top}
  tbody tr:hover{background:#0b1220}
  input[type="number"], input[type="text"], select, textarea{
    width:100%; box-sizing:border-box; padding:6px 8px; background:#0d1420; color:var(--text);
    border:1px solid var(--border); border-radius:8px; font-size:13px;
  }
  textarea{min-height:84px}
  button{background:var(--accent); border:none; color:#fff; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600}
  button.secondary{background:#263445}
  button.ghost{background:transparent; border:1px solid var(--border)}
  .pill{display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid var(--border)}
  .ok{color:#c6f6d5; border-color:#23543f; background:#0f2b1f}
  .warn{color:#fff1c1; border-color:#5d4a1e; background:#2a2316}
  .bad{color:#ffd1d1; border-color:#553232; background:#2a1717}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  .scroll{max-height:360px; overflow:auto; border:1px solid var(--border); border-radius:10px}
  .tight th,.tight td{padding:4px 6px}
  .grid{display:grid; gap:8px; grid-template-columns:repeat(4,minmax(0,1fr))}
  .grid-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .grid-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  .footer{margin-top:18px; display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .help{font-size:12px; line-height:1.35}
  .right{float:right}
  .center{text-align:center}
  .nowrap{white-space:nowrap}
</style>
</head>
<body>

<h1>FRC REEFSCAPE 2025 — Scouting (Tables-only Web App)</h1>
<p class="muted help">Single-file, client-side app. Paste your schedule → auto-prefill Raw Data rows → enter scouting → get team averages, weighted averages, predictions, RP checks, planner, coverage gaps. Data auto-saves to localStorage; you can import/export JSON anytime.</p>

<div class="row">
  <!-- SETTINGS -->
  <section class="card" style="max-width:560px">
    <h2>Settings</h2>
    <table class="tight">
      <tbody>
        <tr><th style="width:40%">Our Team</th>
          <td><input id="ourTeam" type="number" placeholder="e.g., 1234" /></td></tr>
        <tr><th>Decay Factor (weighted avg)</th>
          <td><input id="decay" type="number" step="0.01" min="0" max="1" value="0.85"/></td></tr>
        <tr><th>Max Matches in Schedule</th>
          <td><input id="maxMatches" type="number" value="200"/></td></tr>
      </tbody>
    </table>

    <h3>RP Thresholds</h3>
    <table class="tight">
      <tbody>
        <tr><th>Coral per Level</th><td><input id="rpCoralPerLevel" type="number" value="7"/></td></tr>
        <tr><th>Levels Required (no Coop)</th><td><input id="rpLevels" type="number" value="4"/></td></tr>
        <tr><th>Levels Required (with Coop)</th><td><input id="rpLevelsCoop" type="number" value="3"/></td></tr>
        <tr><th>Barge RP Points</th><td><input id="rpBargePts" type="number" value="16"/></td></tr>
      </tbody>
    </table>

    <div class="footer">
      <button id="saveCfg">Save settings</button>
      <span class="muted">Autosaves too.</span>
    </div>
    <hr/>
    <h3>Import / Export</h3>
    <div class="footer">
      <button id="exportJson">Export JSON</button>
      <label class="ghost pill">
        <input id="importFile" type="file" accept="application/json" style="display:none"/>
        <span class="mono">Import JSON…</span>
      </label>
      <button id="clearStorage" class="secondary">Clear localStorage</button>
    </div>
  </section>

  <!-- RULES + STRATEGY -->
  <section class="card">
    <h2>Rules (REEFSCAPE 2025)</h2>
    <div class="scroll">
      <table id="rulesTbl">
        <thead><tr><th>Item</th><th>Auto</th><th>Tele</th><th>Notes</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
    <h3>Strategy Weights & Reliability Map</h3>
    <table class="tight" id="weightsTbl">
      <tbody>
        <tr><th style="width:40%">Auto Points Weight</th><td><input id="wAuto" type="number" step="0.1" value="1"/></td></tr>
        <tr><th>Teleop Points Weight</th><td><input id="wTele" type="number" step="0.1" value="1"/></td></tr>
        <tr><th>Endgame Points Weight</th><td><input id="wEnd" type="number" step="0.1" value="1"/></td></tr>
        <tr><th>Foul Impact Weight</th><td><input id="wFoul" type="number" step="0.1" value="1"/></td></tr>
        <tr><th>Reliability Floor</th><td><input id="relFloor" type="number" step="0.05" value="0.8"/></td></tr>
        <tr><th>Reliability Ceil</th><td><input id="relCeil" type="number" step="0.05" value="1.2"/></td></tr>
      </tbody>
    </table>
    <div class="footer">
      <button id="saveWeights">Save weights</button>
    </div>
  </section>
</div>

<!-- SCHEDULE -->
<section class="card">
  <h2>Schedule (Copy & Paste)</h2>
  <p class="help">Paste rows with headers: <span class="mono">Event | CompLevel | Set | Match | Time | Red1 | Red2 | Red3 | Blue1 | Blue2 | Blue3</span></p>
  <div class="grid-2">
    <textarea id="schedulePaste" placeholder="Paste schedule rows here…"></textarea>
    <div>
      <div class="footer">
        <button id="parseSchedule">Parse Schedule</button>
        <button id="clearSchedule" class="secondary">Clear</button>
        <button id="exportSchedule" class="ghost">Export CSV</button>
      </div>
      <p class="muted help">After parsing, the app:<br>1) builds **Schedule Expanded** (6 rows per match)<br>2) **prefills Raw Data** (Event/Match/Team/Alliance)</p>
    </div>
  </div>
  <div class="scroll" style="margin-top:10px">
    <table id="scheduleTbl">
      <thead><tr>
        <th>Event</th><th>CompLvl</th><th>Set</th><th>Match</th><th>Time</th>
        <th>Red1</th><th>Red2</th><th>Red3</th><th>Blue1</th><th>Blue2</th><th>Blue3</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- SCHEDULE EXPANDED -->
<section class="card">
  <h2>Schedule Expanded (6 rows per match)</h2>
  <div class="scroll">
    <table id="schedExpTbl">
      <thead><tr>
        <th>Event</th><th>CompLvl</th><th>Set</th><th>Match</th><th>Time</th><th>Alliance</th><th>Team</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- RAW DATA -->
<section class="card">
  <h2>Raw Data (auto-prefilled A:D, you fill the metrics)</h2>
  <div class="footer">
    <button id="addEmptyRow" class="ghost">Add empty row</button>
    <button id="exportRaw" class="ghost">Export CSV</button>
  </div>
  <div class="scroll">
    <table id="rawTbl">
      <thead><tr id="rawHead"></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- PIT SCOUTING -->
<section class="card">
  <h2>Pit Scouting</h2>
  <p class="help">Reliability (1–5) maps to factor using floor/ceil in Strategy Weights.</p>
  <div class="footer">
    <button id="addPitRow" class="ghost">Add Row</button>
    <button id="exportPit" class="ghost">Export CSV</button>
  </div>
  <div class="scroll">
    <table id="pitTbl">
      <thead><tr>
        <th>Team</th><th>Drivetrain</th><th>Max Coral Level</th><th>Auto Coral (Y/N)</th>
        <th>Cage Capability</th><th>Alg → Processor (Y/N)</th><th>Alg → Net (Y/N)</th>
        <th>Reliability (1–5)</th><th>Notes</th><th>ReliabilityFactor</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- TEAM AVERAGES -->
<section class="card">
  <h2>Team Averages (Simple)</h2>
  <div class="footer">
    <button id="recompute">Recompute</button>
  </div>
  <div class="scroll">
    <table id="avgTbl">
      <thead><tr id="avgHead"></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- WEIGHTED AVERAGES -->
<section class="card">
  <h2>Weighted Averages (Recent-weighted)</h2>
  <div class="scroll">
    <table id="wavgTbl">
      <thead><tr id="wavgHead"></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- MATCH PREDICTOR / DASHBOARD -->
<section class="card">
  <h2>Match Predictor & RP Checks</h2>
  <div class="grid-3">
    <table class="tight">
      <tbody>
        <tr><th>Pick schedule match #</th>
          <td>
            <select id="pickMatch"><option value="">—</option></select>
          </td></tr>
        <tr><th>or enter teams (Red)</th>
          <td class="grid-3"><input id="r1" type="number" placeholder="Red1"/><input id="r2" type="number" placeholder="Red2"/><input id="r3" type="number" placeholder="Red3"/></td></tr>
        <tr><th>enter teams (Blue)</th>
          <td class="grid-3"><input id="b1" type="number" placeholder="Blue1"/><input id="b2" type="number" placeholder="Blue2"/><input id="b3" type="number" placeholder="Blue3"/></td></tr>
      </tbody>
    </table>
    <table>
      <thead><tr><th>Totals</th><th>Red</th><th>Blue</th></tr></thead>
      <tbody>
        <tr><td>Simple</td><td id="predRedSimple">—</td><td id="predBlueSimple">—</td></tr>
        <tr><td>Weighted</td><td id="predRedWeighted">—</td><td id="predBlueWeighted">—</td></tr>
        <tr><td>Custom + Reliability</td><td id="predRedCustom">—</td><td id="predBlueCustom">—</td></tr>
      </tbody>
    </table>
    <table>
      <thead><tr><th>RP Checks (approx)</th><th>Red</th></tr></thead>
      <tbody>
        <tr><td>AUTO RP?</td><td id="rpAuto">—</td></tr>
        <tr><td>CORAL RP?</td><td id="rpCoral">—</td></tr>
        <tr><td>BARGE RP?</td><td id="rpBarge">—</td></tr>
        <tr><td>Coop Bonus likely?</td><td id="rpCoop">—</td></tr>
      </tbody>
    </table>
  </div>
</section>

<!-- SCOUT PLANNER -->
<section class="card">
  <h2>Scout Planner</h2>
  <p class="help">Shows our matches, partners/opponents, and a list of teams to scout, with coverage gaps.</p>
  <div class="row">
    <div class="card" style="min-width:360px">
      <h3>Our Matches</h3>
      <div class="scroll">
        <table id="ourMatchesTbl">
          <thead><tr><th>Match</th><th>Alliance</th><th>Partners</th><th>Opponents</th><th>Time</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
    <div class="card" style="min-width:360px">
      <h3>Priority Teams to Scout</h3>
      <div class="scroll">
        <table id="priorityTbl">
          <thead><tr><th>Team</th><th>First Shared Match</th><th>Role vs Us</th><th>Scouted Rows</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <h3>Opponents by Match (coverage gaps)</h3>
      <div class="scroll">
        <table id="oppChecklistTbl">
          <thead><tr><th>Match</th><th>Opp1</th><th>Opp2</th><th>Opp3</th><th>Gaps</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>
</section>

<script>
/* =========================
   Data model & persistence
   ========================= */
const state = {
  config: {
    ourTeam: "",
    decay: 0.85,
    maxMatches: 200,
    rp: { coralPerLevel:7, levels:4, levelsCoop:3, bargePts:16 }
  },
  weights: { wAuto:1, wTele:1, wEnd:1, wFoul:1, relFloor:0.8, relCeil:1.2 },
  rules: [
    { item:"LEAVE", auto:3, tele:0, notes:"AUTO mobility" },
    { item:"CORAL L1 (trough)", auto:3, tele:2, notes:"" },
    { item:"CORAL L2", auto:4, tele:3, notes:"" },
    { item:"CORAL L3", auto:6, tele:4, notes:"" },
    { item:"CORAL L4", auto:7, tele:5, notes:"" },
    { item:"ALGAE in PROCESSOR", auto:6, tele:6, notes:"same value" },
    { item:"ALGAE in NET", auto:4, tele:4, notes:"same value" },
    { item:"PARK", auto:0, tele:2, notes:"endgame" },
    { item:"CAGE SHALLOW", auto:0, tele:6, notes:"endgame" },
    { item:"CAGE DEEP", auto:0, tele:12, notes:"endgame" },
    { item:"MINOR FOUL (opp +2)", auto:0, tele:2, notes:"opponent gets points" },
    { item:"MAJOR FOUL (opp +6)", auto:0, tele:6, notes:"opponent gets points" },
  ],
  schedule: [],           // [{event,comp,set,match,time,red:[t1,t2,t3],blue:[t1,t2,t3]}]
  scheduleExpanded: [],   // computed: [{event,comp,set,match,time,alliance,team}]
  raw: [],                // rows for scouting
  pit: []                 // pit scouting rows
};

// localStorage helpers
const LS_KEY = "reefscape2025_scout";
function saveAll(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
function loadAll(){
  const s = localStorage.getItem(LS_KEY);
  if (!s) return;
  try {
    const o = JSON.parse(s);
    ["config","weights","rules","schedule","scheduleExpanded","raw","pit"].forEach(k=>{
      if (o[k]!==undefined) state[k]=o[k];
    });
  } catch(e){ console.warn("loadAll failed", e); }
}

/* =========================
   Utilities
   ========================= */
const qs = sel => document.querySelector(sel);
function csvEscape(v){ if(v==null) return ""; v = String(v); return /[,"\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v; }
function toCSV(rows){
  return rows.map(r => Object.values(r).map(csvEscape).join(",")).join("\n");
}
function download(filename, text){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([text], {type:"text/plain"}));
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}
function uniq(arr){ return [...new Set(arr)]; }
function sum(arr){ return arr.reduce((a,b)=>a+(+b||0),0); }
function avg(arr){ const v=arr.filter(x=>x!=="" && x!=null); return v.length? sum(v)/v.length : 0; }
function by(obj, key, def=0){ return obj?.[key] ?? def; }
function asInt(v){ const n = parseInt(v,10); return isFinite(n)? n : 0; }
function asNum(v){ const n = Number(v); return isFinite(n)? n : 0; }
function sortedNumeric(a){ return [...a].sort((x,y)=>x-y); }
function teamKey(t){ return String(t||"").trim(); }
function mkRow(cols){ const tr=document.createElement("tr"); cols.forEach(c=>{ const td=document.createElement("td"); if(c instanceof Node){ td.appendChild(c);} else {td.innerHTML=c;} tr.appendChild(td); }); return tr; }

/* =========================
   Render rules & weight tables
   ========================= */
function renderRules(){
  const tb = qs("#rulesTbl tbody"); tb.innerHTML="";
  state.rules.forEach(r=>{
    tb.appendChild(mkRow([r.item, r.auto, r.tele, r.notes]));
  });
}
function bindSettings(){
  qs("#ourTeam").value = state.config.ourTeam || "";
  qs("#decay").value = state.config.decay;
  qs("#maxMatches").value = state.config.maxMatches;
  qs("#rpCoralPerLevel").value = state.config.rp.coralPerLevel;
  qs("#rpLevels").value = state.config.rp.levels;
  qs("#rpLevelsCoop").value = state.config.rp.levelsCoop;
  qs("#rpBargePts").value = state.config.rp.bargePts;

  qs("#wAuto").value = state.weights.wAuto;
  qs("#wTele").value = state.weights.wTele;
  qs("#wEnd").value = state.weights.wEnd;
  qs("#wFoul").value = state.weights.wFoul;
  qs("#relFloor").value = state.weights.relFloor;
  qs("#relCeil").value = state.weights.relCeil;
}
function saveSettings(){
  state.config.ourTeam = qs("#ourTeam").value.trim();
  state.config.decay = asNum(qs("#decay").value);
  state.config.maxMatches = asInt(qs("#maxMatches").value);
  state.config.rp.coralPerLevel = asInt(qs("#rpCoralPerLevel").value);
  state.config.rp.levels = asInt(qs("#rpLevels").value);
  state.config.rp.levelsCoop = asInt(qs("#rpLevelsCoop").value);
  state.config.rp.bargePts = asInt(qs("#rpBargePts").value);
  saveAll(); recomputeEverything();
}
function saveWeights(){
  state.weights.wAuto = asNum(qs("#wAuto").value);
  state.weights.wTele = asNum(qs("#wTele").value);
  state.weights.wEnd  = asNum(qs("#wEnd").value);
  state.weights.wFoul = asNum(qs("#wFoul").value);
  state.weights.relFloor = asNum(qs("#relFloor").value);
  state.weights.relCeil  = asNum(qs("#relCeil").value);
  saveAll(); recomputeEverything();
}

/* =========================
   Schedule parsing & display
   ========================= */
function parseScheduleText(txt){
  // Accept CSV or whitespace / tab-delimited lines.
  const rows = txt.trim().split(/\r?\n/).filter(Boolean);
  const out = [];
  for (const line of rows){
    // Try CSV first
    let parts = line.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/).map(s=>s.replace(/^"(.*)"$/,'$1').trim());
    if (parts.length < 11){
      parts = line.split(/\t|\s{2,}/).map(s=>s.trim());
    }
    if (parts.length < 11) continue;
    const [event,comp,set,match,time, r1,r2,r3, b1,b2,b3] = parts;
    out.push({
      event, comp, set:asInt(set), match:asInt(match), time,
      red:[r1,r2,r3].map(asInt), blue:[b1,b2,b3].map(asInt)
    });
  }
  // sort by comp->match, put quals (qm) first
  out.sort((a,b)=> (a.comp||"").localeCompare(b.comp||"") || a.match-b.match);
  return out.slice(0, state.config.maxMatches);
}
function renderSchedule(){
  const tb = qs("#scheduleTbl tbody"); tb.innerHTML="";
  const matchSelect = qs("#pickMatch"); matchSelect.innerHTML = `<option value="">—</option>`;
  state.schedule.forEach(m=>{
    tb.appendChild(mkRow([m.event,m.comp,m.set,m.match,m.time, ...m.red, ...m.blue]));
    if (m.comp && m.comp.toLowerCase().startsWith("qm")){
      const opt = document.createElement("option");
      opt.value=String(m.match); opt.textContent = m.match;
      matchSelect.appendChild(opt);
    }
  });
}
function expandSchedule(){
  const rows = [];
  for (const m of state.schedule){
    const base = {event:m.event, comp:m.comp, set:m.set, match:m.match, time:m.time};
    for (let i=0;i<3;i++) rows.push({...base, alliance:"Red", team: m.red[i]||""});
    for (let i=0;i<3;i++) rows.push({...base, alliance:"Blue", team: m.blue[i]||""});
  }
  state.scheduleExpanded = rows;
}
function renderSchedExpanded(){
  const tb = qs("#schedExpTbl tbody"); tb.innerHTML="";
  state.scheduleExpanded.forEach(r=>{
    tb.appendChild(mkRow([r.event,r.comp,r.set,r.match,r.time,r.alliance,r.team]));
  });
}

/* =========================
   Raw Data table (prefill A:D)
   ========================= */
const RAW_HEADERS = [
  "Event","Match","Team","Alliance",
  "AUTO: Leave","AUTO: L1","AUTO: L2","AUTO: L3","AUTO: L4",
  "AUTO: Alg→Proc","AUTO: Alg→Net",
  "TELE: L1","TELE: L2","TELE: L3","TELE: L4",
  "TELE: Alg→Proc","TELE: Alg→Net",
  "END: Park","END: Shallow","END: Deep",
  "Fouls: Minor","Fouls: Major",
  "Notes",
  "AUTO Pts","TELE Pts","END Pts","TOTAL","Opp Pts From Fouls"
];
const RAW_NUM_COLS = new Set(RAW_HEADERS.slice(4, RAW_HEADERS.length-5)); // editable numeric metrics
function renderRawHeaders(){
  const tr = qs("#rawHead"); tr.innerHTML="";
  RAW_HEADERS.forEach(h=>{ const th=document.createElement("th"); th.textContent=h; tr.appendChild(th); });
}
function prefillRawFromSchedule(){
  const keySet = new Set(state.raw.map(r => `${r.match}#${r.team}`));
  for (const r of state.scheduleExpanded){
    const key = `${r.match}#${r.team}`;
    if (!r.team || keySet.has(key)) continue;
    state.raw.push({
      Event:r.event, Match:r.match, Team:r.team, Alliance:r.alliance,
      "AUTO: Leave":0,"AUTO: L1":0,"AUTO: L2":0,"AUTO: L3":0,"AUTO: L4":0,
      "AUTO: Alg→Proc":0,"AUTO: Alg→Net":0,
      "TELE: L1":0,"TELE: L2":0,"TELE: L3":0,"TELE: L4":0,
      "TELE: Alg→Proc":0,"TELE: Alg→Net":0,
      "END: Park":0,"END: Shallow":0,"END: Deep":0,
      "Fouls: Minor":0,"Fouls: Major":0,
      "Notes":"", "AUTO Pts":0,"TELE Pts":0,"END Pts":0,"TOTAL":0,"Opp Pts From Fouls":0
    });
    keySet.add(key);
  }
}
function renderRaw(){
  const tb = qs("#rawTbl tbody"); tb.innerHTML="";
  for (let i=0;i<state.raw.length;i++){
    const row = state.raw[i];
    const tds = [];
    RAW_HEADERS.forEach(h=>{
      if (["Event","Match","Team","Alliance","AUTO Pts","TELE Pts","END Pts","TOTAL","Opp Pts From Fouls"].includes(h)){
        const val = row[h] ?? "";
        tds.push(`<span class="mono">${val}</span>`);
      } else if (h==="Notes"){
        const inp = document.createElement("input"); inp.type="text"; inp.value=row[h]||"";
        inp.onchange = e=>{ row[h]=e.target.value; computePointsForRow(row); saveAll(); };
        tds.push(inp);
      } else {
        // numeric editable
        const inp = document.createElement("input"); inp.type="number"; inp.step="1"; inp.value=row[h]||0;
        inp.onchange = e=>{ row[h]=asNum(e.target.value); computePointsForRow(row); saveAll(); };
        tds.push(inp);
      }
    });
    qs("#rawTbl tbody").appendChild(mkRow(tds));
  }
}

/* =========================
   Points computation per row
   ========================= */
const RULE = {
  LEAVE: {auto:3, tele:0},
  L1: {auto:3, tele:2},
  L2: {auto:4, tele:3},
  L3: {auto:6, tele:4},
  L4: {auto:7, tele:5},
  ALG_PROC: {auto:6, tele:6},
  ALG_NET: {auto:4, tele:4},
  PARK: {auto:0, tele:2},
  CAGE_SH: {auto:0, tele:6},
  CAGE_DP: {auto:0, tele:12}
};
function computePointsForRow(r){
  // auto
  const auto = (r["AUTO: Leave"]||0)*RULE.LEAVE.auto
             + (r["AUTO: L1"]||0)*RULE.L1.auto
             + (r["AUTO: L2"]||0)*RULE.L2.auto
             + (r["AUTO: L3"]||0)*RULE.L3.auto
             + (r["AUTO: L4"]||0)*RULE.L4.auto
             + (r["AUTO: Alg→Proc"]||0)*RULE.ALG_PROC.auto
             + (r["AUTO: Alg→Net"]||0)*RULE.ALG_NET.auto;
  // tele
  const tele = (r["TELE: L1"]||0)*RULE.L1.tele
             + (r["TELE: L2"]||0)*RULE.L2.tele
             + (r["TELE: L3"]||0)*RULE.L3.tele
             + (r["TELE: L4"]||0)*RULE.L4.tele
             + (r["TELE: Alg→Proc"]||0)*RULE.ALG_PROC.tele
             + (r["TELE: Alg→Net"]||0)*RULE.ALG_NET.tele;
  // endgame
  const endp = (r["END: Park"]||0)*RULE.PARK.tele
             + (r["END: Shallow"]||0)*RULE.CAGE_SH.tele
             + (r["END: Deep"]||0)*RULE.CAGE_DP.tele;
  r["AUTO Pts"]=auto; r["TELE Pts"]=tele; r["END Pts"]=endp;
  r["TOTAL"]=auto+tele+endp;
  r["Opp Pts From Fouls"] = 2*(r["Fouls: Minor"]||0) + 6*(r["Fouls: Major"]||0);
}
function recomputeAllPoints(){ state.raw.forEach(computePointsForRow); }

/* =========================
   Pit table
   ========================= */
function renderPit(){
  const tb = qs("#pitTbl tbody"); tb.innerHTML="";
  const optsDT = ["","Swerve","Tank","West Coast","Mecanum","Other"];
  const optsLvl = ["","L1","L2","L3","L4"];
  const optsYN = ["","Y","N"];
  const optsCage = ["","None","Park","Shallow","Deep"];
  state.pit.forEach((r,idx)=>{
    const mkSel = (arr,val,onchange)=>{ const s=document.createElement("select"); arr.forEach(x=>{const o=document.createElement("option");o.value=x;o.textContent=x;s.appendChild(o);}); s.value=val||""; s.onchange=onchange; return s; };
    const mkInp = (val,on)=>{ const i=document.createElement("input"); i.value=val||""; i.onchange=on; return i; };
    const mkNum = (val,on)=>{ const i=document.createElement("input"); i.type="number"; i.min="1"; i.max="5"; i.step="1"; i.value=val||""; i.onchange=on; return i; };

    const rel = reliabilityFactor(r.Team);
    const tr = mkRow([
      mkInp(r.Team, e=>{r.Team=asInt(e.target.value); saveAll();}),
      mkSel(optsDT, r.Drivetrain, e=>{r.Drivetrain=e.target.value; saveAll();}),
      mkSel(optsLvl, r.MaxCoralLevel, e=>{r.MaxCoralLevel=e.target.value; saveAll();}),
      mkSel(optsYN, r.AutoCoral, e=>{r.AutoCoral=e.target.value; saveAll();}),
      mkSel(optsCage, r.CageCap, e=>{r.CageCap=e.target.value; saveAll();}),
      mkSel(optsYN, r.AlgProc, e=>{r.AlgProc=e.target.value; saveAll();}),
      mkSel(optsYN, r.AlgNet, e=>{r.AlgNet=e.target.value; saveAll();}),
      mkNum(r.Reliability, e=>{r.Reliability=asInt(e.target.value); saveAll(); renderPit();}),
      mkInp(r.Notes, e=>{r.Notes=e.target.value; saveAll();}),
      `<span class="pill ${rel>=1?'ok':'warn'} mono">${rel.toFixed(2)}</span>`
    ]);
    tb.appendChild(tr);
  });
}
qs("#addPitRow").onclick = ()=>{ state.pit.push({Team:""}); renderPit(); saveAll(); };

/* =========================
   Averages (simple & weighted)
   ========================= */
const AVG_HEADERS = [
  "Team","Matches",
  "AUTO Leave","AUTO L1","AUTO L2","AUTO L3","AUTO L4",
  "AUTO AlgProc","AUTO AlgNet",
  "TELE L1","TELE L2","TELE L3","TELE L4",
  "TELE AlgProc","TELE AlgNet",
  "END Park","END Shallow","END Deep",
  "Avg AUTO","Avg TELE","Avg END","Avg TOTAL","Avg FOUL to Opp"
];
function renderAvgHeaders(){
  const tr = qs("#avgHead"); tr.innerHTML="";
  AVG_HEADERS.forEach(h=>{const th=document.createElement("th"); th.textContent=h; tr.appendChild(th);});
  const trW = qs("#wavgHead"); trW.innerHTML="";
  AVG_HEADERS.forEach(h=>{const th=document.createElement("th"); th.textContent=(h==="Avg TOTAL"?"Wgt TOTAL":h.replace("Avg ","Wgt ")); trW.appendChild(th);});
}
function groupRowsByTeam(){
  const map = new Map();
  for (const r of state.raw){
    const t = teamKey(r.Team); if (!t) continue;
    if (!map.has(t)) map.set(t, []);
    map.get(t).push(r);
  }
  return map;
}
function computeSimpleAverages(){
  const map = groupRowsByTeam();
  const rows = [];
  for (const [team, arr] of map.entries()){
    const getA = k => avg(arr.map(r=>asNum(r[k])));
    const matches = arr.length;
    rows.push({
      Team:team, Matches:matches,
      "AUTO Leave":getA("AUTO: Leave"),
      "AUTO L1":getA("AUTO: L1"),"AUTO L2":getA("AUTO: L2"),"AUTO L3":getA("AUTO: L3"),"AUTO L4":getA("AUTO: L4"),
      "AUTO AlgProc":getA("AUTO: Alg→Proc"), "AUTO AlgNet":getA("AUTO: Alg→Net"),
      "TELE L1":getA("TELE: L1"),"TELE L2":getA("TELE: L2"),"TELE L3":getA("TELE: L3"),"TELE L4":getA("TELE: L4"),
      "TELE AlgProc":getA("TELE: Alg→Proc"), "TELE AlgNet":getA("TELE: Alg→Net"),
      "END Park":getA("END: Park"), "END Shallow":getA("END: Shallow"), "END Deep":getA("END: Deep"),
      "Avg AUTO":avg(arr.map(r=>r["AUTO Pts"])), "Avg TELE":avg(arr.map(r=>r["TELE Pts"])), "Avg END":avg(arr.map(r=>r["END Pts"])),
      "Avg TOTAL":avg(arr.map(r=>r["TOTAL"])), "Avg FOUL to Opp":avg(arr.map(r=>r["Opp Pts From Fouls"]))
    });
  }
  // Sort by team #
  rows.sort((a,b)=>asInt(a.Team)-asInt(b.Team));
  return rows;
}
function latestMatchPerTeam(arr){ return arr.reduce((m,r)=>Math.max(m, asInt(r.Match)||0), 0); }
function computeWeightedAverages(decay){
  const map = groupRowsByTeam();
  const rows = [];
  for (const [team, arr] of map.entries()){
    const latest = latestMatchPerTeam(arr);
    const w = r => Math.pow(decay, Math.max(0, latest - (asInt(r.Match)||0)));
    const wavg = key => {
      let num=0,den=0;
      for (const r of arr){ const val=asNum(r[key]); const wt=w(r); if(isFinite(val)){ num+=val*wt; den+=wt; } }
      return den? num/den : 0;
    };
    rows.push({
      Team:team, Matches:arr.length,
      "AUTO Leave":wavg("AUTO: Leave"),
      "AUTO L1":wavg("AUTO: L1"),"AUTO L2":wavg("AUTO: L2"),"AUTO L3":wavg("AUTO: L3"),"AUTO L4":wavg("AUTO: L4"),
      "AUTO AlgProc":wavg("AUTO: Alg→Proc"), "AUTO AlgNet":wavg("AUTO: Alg→Net"),
      "TELE L1":wavg("TELE: L1"),"TELE L2":wavg("TELE: L2"),"TELE L3":wavg("TELE: L3"),"TELE L4":wavg("TELE: L4"),
      "TELE AlgProc":wavg("TELE: Alg→Proc"), "TELE AlgNet":wavg("TELE: Alg→Net"),
      "END Park":wavg("END: Park"), "END Shallow":wavg("END: Shallow"), "END Deep":wavg("END: Deep"),
      "Avg AUTO":wavg("AUTO Pts"), "Avg TELE":wavg("TELE Pts"), "Avg END":wavg("END Pts"),
      "Wgt TOTAL":wavg("TOTAL"), "Avg FOUL to Opp":wavg("Opp Pts From Fouls")
    });
  }
  rows.sort((a,b)=>asInt(a.Team)-asInt(b.Team));
  return rows;
}
function renderTableFromObjects(tblId, rows, headers){
  const tb = qs(`#${tblId} tbody`); tb.innerHTML="";
  rows.forEach(r=>{
    const cols = headers.map(h => (h in r) ? (typeof r[h]==="number" ? r[h].toFixed(2) : r[h]) : "");
    tb.appendChild(mkRow(cols));
  });
}

/* =========================
   Predictor (simple / weighted / custom)
   ========================= */
function reliabilityFactor(team){
  const t = asInt(team);
  const row = state.pit.find(x=>asInt(x.Team)===t);
  if (!row) return 1;
  const rel = asInt(row.Reliability||0);
  const f = state.weights.relFloor, c = state.weights.relCeil;
  if (!rel) return 1;
  return f + (rel-1)*(c-f)/4;
}
function indexByTeam(rows){
  const m = new Map();
  rows.forEach(r => m.set(asInt(r.Team), r));
  return m;
}
function pickTeamsFromMatch(){
  const match = asInt(qs("#pickMatch").value);
  if (!match) return;
  const s = state.schedule.find(m => asInt(m.match)===match);
  if (!s) return;
  qs("#r1").value = s.red[0]||""; qs("#r2").value = s.red[1]||""; qs("#r3").value = s.red[2]||"";
  qs("#b1").value = s.blue[0]||""; qs("#b2").value = s.blue[1]||""; qs("#b3").value = s.blue[2]||"";
  computePredictions();
}
function fetchAllianceTeams(){
  const r = [qs("#r1").value, qs("#r2").value, qs("#r3").value].map(asInt).filter(Boolean);
  const b = [qs("#b1").value, qs("#b2").value, qs("#b3").value].map(asInt).filter(Boolean);
  return {r,b};
}
function sumTeams(rowsIndex, teams, field){
  return sum(teams.map(t => asNum(rowsIndex.get(t)?.[field] || 0)));
}
function coralLevelTotals(rowsIndex, teams){
  // sum of AUTO + TELE L1..L4 (counts, not points)
  const sumField = (f)=>sum(teams.map(t => asNum(rowsIndex.get(t)?.[f]||0)));
  return {
    L1: sumField("AUTO L1")+sumField("TELE L1"),
    L2: sumField("AUTO L2")+sumField("TELE L2"),
    L3: sumField("AUTO L3")+sumField("TELE L3"),
    L4: sumField("AUTO L4")+sumField("TELE L4"),
  };
}
function computePredictions(){
  const {r,b} = fetchAllianceTeams();
  const simple = computeSimpleAverages(); const sm = indexByTeam(simple);
  const weighted = computeWeightedAverages(state.config.decay); const wm = indexByTeam(weighted);

  // Simple/Weighted totals (Avg TOTAL / Wgt TOTAL)
  qs("#predRedSimple").textContent = sumTeams(sm, r, "Avg TOTAL").toFixed(1);
  qs("#predBlueSimple").textContent = sumTeams(sm, b, "Avg TOTAL").toFixed(1);
  qs("#predRedWeighted").textContent = sumTeams(wm, r, "Wgt TOTAL").toFixed(1);
  qs("#predBlueWeighted").textContent = sumTeams(wm, b, "Wgt TOTAL").toFixed(1);

  // Custom + Reliability
  const W = state.weights;
  function customFor(team, m){
    const A = asNum(m.get(team)?.["Avg AUTO"]||0);
    const T = asNum(m.get(team)?.["Avg TELE"]||0);
    const E = asNum(m.get(team)?.["Avg END"]||0);
    const F = asNum(m.get(team)?.["Avg FOUL to Opp"]||0);
    const rf = reliabilityFactor(team);
    return (A*W.wAuto + T*W.wTele + E*W.wEnd - F*W.wFoul) * rf;
  }
  const rC = sum(r.map(t => customFor(t, sm)));
  const bC = sum(b.map(t => customFor(t, sm)));
  qs("#predRedCustom").textContent = rC.toFixed(1);
  qs("#predBlueCustom").textContent = bC.toFixed(1);

  // RP checks (use simple averages)
  const leaveSum = sumTeams(sm, r, "AUTO Leave");
  const autoCoralAny = (sumTeams(sm, r, "AUTO L1")+sumTeams(sm, r, "AUTO L2")
                      +sumTeams(sm, r, "AUTO L3")+sumTeams(sm, r, "AUTO L4")) > 0 ? "Yes" : "No";
  qs("#rpAuto").textContent = (leaveSum >= 2.5 && autoCoralAny==="Yes") ? "Likely" : "Unlikely/Maybe";

  const C = state.config.rp; const L = coralLevelTotals(sm, r);
  const levels = (L.L1>=C.coralPerLevel) + (L.L2>=C.coralPerLevel) + (L.L3>=C.coralPerLevel) + (L.L4>=C.coralPerLevel);
  qs("#rpCoral").textContent = (levels>=C.levels) ? "Likely (no Coop)" : (levels>=C.levelsCoop ? "Maybe (with Coop)" : "Unlikely");

  const endPts = 2*sumTeams(sm, r, "END Park") + 6*sumTeams(sm, r, "END Shallow") + 12*sumTeams(sm, r, "END Deep");
  qs("#rpBarge").textContent = (endPts >= C.bargePts) ? "Likely" : "Unlikely/Maybe";

  const redProc = sumTeams(sm, r, "AUTO AlgProc")+sumTeams(sm, r, "TELE AlgProc");
  const blueProc = sumTeams(sm, b, "AUTO AlgProc")+sumTeams(sm, b, "TELE AlgProc");
  qs("#rpCoop").textContent = (redProc>=2 && blueProc>=2) ? "Likely" : "Unlikely/Depends";
}

/* =========================
   Planner (our matches, priority, gaps)
   ========================= */
function renderPlanner(){
  const our = asInt(state.config.ourTeam);
  const ours = state.scheduleExpanded.filter(r=>asInt(r.team)===our);
  const ourMatches = uniq(ours.map(r=>asInt(r.match))).sort((a,b)=>a-b);
  // Our matches table
  const tb = qs("#ourMatchesTbl tbody"); tb.innerHTML="";
  for (const m of ourMatches){
    const rows = state.scheduleExpanded.filter(r=>asInt(r.match)===m);
    const ourRow = rows.find(r=>asInt(r.team)===our);
    const ourAlliance = ourRow?.alliance || "";
    const partners = rows.filter(r=>r.alliance===ourAlliance && asInt(r.team)!==our).map(r=>r.team).join(", ");
    const opps = rows.filter(r=>r.alliance!==ourAlliance).map(r=>r.team).join(", ");
    const time = (state.schedule.find(x=>asInt(x.match)===m)||{}).time || "";
    tb.appendChild(mkRow([m, ourAlliance, partners, opps, time]));
  }
  // Priority teams list
  const teamsWeFace = uniq(
    ourMatches.flatMap(m => state.scheduleExpanded.filter(r=>asInt(r.match)===m && asInt(r.team)!==our).map(r=>asInt(r.team)))
  ).sort((a,b)=>a-b);
  const tb2 = qs("#priorityTbl tbody"); tb2.innerHTML="";
  for (const t of teamsWeFace){
    const firstShared = ourMatches.find(m => state.scheduleExpanded.some(r=>asInt(r.match)===m && asInt(r.team)===t));
    const rowAtMatch = state.scheduleExpanded.find(r=>asInt(r.match)===firstShared && asInt(r.team)===t);
    const ourRowAtMatch = state.scheduleExpanded.find(r=>asInt(r.match)===firstShared && asInt(r.team)===our);
    const role = (rowAtMatch?.alliance === ourRowAtMatch?.alliance) ? "Partner" : "Opponent";
    const scoutedRows = state.raw.filter(r=>asInt(r.Team)===t && asNum(r["TOTAL"])>0).length;
    const chip = scoutedRows>0 ? `<span class="pill ok">${scoutedRows}</span>` : `<span class="pill bad">0</span>`;
    tb2.appendChild(mkRow([t, firstShared??"", role, chip]));
  }
  // Opponents checklist + coverage gaps
  const tb3 = qs("#oppChecklistTbl tbody"); tb3.innerHTML="";
  for (const m of ourMatches){
    const rows = state.scheduleExpanded.filter(r=>asInt(r.match)===m);
    const ourRow = rows.find(r=>asInt(r.team)===our);
    const opps = rows.filter(r=>r.alliance!==ourRow?.alliance).map(r=>asInt(r.team));
    const gaps = opps.filter(t => state.raw.filter(r=>asInt(r.Team)===t && asNum(r["TOTAL"])>0).length===0);
    const gapCell = gaps.length? `<span class="pill warn mono">${gaps.join(", ")}</span>` : `<span class="pill ok">none</span>`;
    tb3.appendChild(mkRow([m, opps[0]||"", opps[1]||"", opps[2]||"", gapCell]));
  }
}

/* =========================
   Rendering helpers
   ========================= */
function renderSchedulePicklist(){
  const sel=qs("#pickMatch");
  const seen=new Set();
  sel.innerHTML='<option value="">—</option>';
  for (const s of state.schedule){
    if (s.comp?.toLowerCase().startsWith("qm") && !seen.has(s.match)){
      const o=document.createElement("option");
      o.value=String(s.match); o.textContent=s.match;
      sel.appendChild(o); seen.add(s.match);
    }
  }
}

/* =========================
   Exporters
   ========================= */
qs("#exportSchedule").onclick = ()=>{
  const rows = state.schedule.map(m => ({
    Event:m.event, CompLevel:m.comp, Set:m.set, Match:m.match, Time:m.time,
    Red1:m.red[0], Red2:m.red[1], Red3:m.red[2], Blue1:m.blue[0], Blue2:m.blue[1], Blue3:m.blue[2]
  }));
  download("schedule.csv", toCSV(rows));
};
qs("#exportRaw").onclick = ()=>{
  download("raw_data.csv", toCSV(state.raw));
};
qs("#exportPit").onclick = ()=>{
  download("pit_scouting.csv", toCSV(state.pit));
};
qs("#exportJson").onclick = ()=>{
  download("reefscape_scouter.json", JSON.stringify(state, null, 2));
};
qs("#importFile").onchange = (e)=>{
  const f = e.target.files?.[0]; if(!f) return;
  const fr = new FileReader();
  fr.onload = ()=>{
    try{
      const obj = JSON.parse(fr.result);
      Object.assign(state, obj);
      saveAll(); boot();
    }catch(err){ alert("Invalid JSON"); }
  };
  fr.readAsText(f);
};
qs("#clearStorage").onclick = ()=>{ if(confirm("Clear localStorage & reset?")){ localStorage.removeItem(LS_KEY); location.reload(); } };

/* =========================
   Wire UI
   ========================= */
qs("#saveCfg").onclick = saveSettings;
qs("#saveWeights").onclick = saveWeights;
qs("#parseSchedule").onclick = ()=>{
  const txt = qs("#schedulePaste").value;
  state.schedule = parseScheduleText(txt);
  expandSchedule();
  prefillRawFromSchedule();
  recomputeAllPoints();
  renderSchedule();
  renderSchedExpanded();
  renderSchedulePicklist();
  renderRaw();
  renderPlanner();
  saveAll();
};
qs("#clearSchedule").onclick = ()=>{
  state.schedule = []; state.scheduleExpanded = [];
  renderSchedule(); renderSchedExpanded(); renderSchedulePicklist(); saveAll();
};
qs("#addEmptyRow").onclick = ()=>{
  const r = {};
  RAW_HEADERS.forEach(h=>r[h]="");
  r["AUTO Pts"]=0; r["TELE Pts"]=0; r["END Pts"]=0; r["TOTAL"]=0; r["Opp Pts From Fouls"]=0;
  state.raw.push(r); renderRaw(); saveAll();
};
qs("#recompute").onclick = ()=>{ recomputeEverything(); };
qs("#pickMatch").onchange = pickTeamsFromMatch;
["#r1","#r2","#r3","#b1","#b2","#b3"].forEach(id=>{ qs(id).addEventListener("input", computePredictions); });

/* =========================
   Main recompute
   ========================= */
function recomputeEverything(){
  recomputeAllPoints();
  const simple = computeSimpleAverages();
  renderTableFromObjects("avgTbl", simple, AVG_HEADERS);
  const weighted = computeWeightedAverages(state.config.decay);
  renderTableFromObjects("wavgTbl", weighted, AVG_HEADERS.map(h=> h==="Avg TOTAL"?"Wgt TOTAL":h.replace("Avg ","Wgt ")));
  renderPlanner();
  computePredictions();
  saveAll();
}

/* =========================
   Boot
   ========================= */
function renderScheduleTable(){
  renderSchedule();
  renderSchedExpanded();
  renderSchedulePicklist();
}
function boot(){
  loadAll();
  renderRules();
  bindSettings();
  renderRawHeaders();
  renderPit();
  renderScheduleTable();
  renderAvgHeaders();
  renderRaw();
  recomputeEverything();
}
boot();
</script>
</body>
</html>
