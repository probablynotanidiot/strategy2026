<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FRC REEFSCAPE 2025 Scouting (with TBA Fetch)</title>
<style>
  :root{
    --bg:#0b0f14; --card:#111722; --muted:#98a2b3; --text:#e6edf3; --accent:#2e7dd7; --accent2:#00b894; --warn:#ffd166;
    --border:#1f2a3a;
  }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,"Noto Sans";
       background:var(--bg); color:var(--text); margin:0; padding:24px;}
  h1,h2{margin:12px 0 8px}
  small, .muted{color:var(--muted)}
  .row{display:flex; gap:16px; flex-wrap:wrap}
  .card{background:var(--card); border:1px solid var(--border); border-radius:12px; padding:14px; flex:1 1 420px; min-width:360px}
  table{width:100%; border-collapse:collapse; font-size:13px; border:1px solid var(--border); background:#0f1520}
  thead th{position:sticky; top:0; background:#0e1522; z-index:1}
  th, td{border-bottom:1px solid var(--border); padding:6px 8px; text-align:left; vertical-align:top}
  tbody tr:hover{background:#0b1220}
  input[type="number"], input[type="text"], input[type="password"], select, textarea{
    width:100%; box-sizing:border-box; padding:6px 8px; background:#0d1420; color:var(--text);
    border:1px solid var(--border); border-radius:8px; font-size:13px;
  }
  input[type="checkbox"]{transform:scale(1.2); cursor:pointer}
  textarea{min-height:84px}
  button{background:var(--accent); border:none; color:#fff; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600}
  button.secondary{background:#263445}
  button.ghost{background:transparent; border:1px solid var(--border)}
  .pill{display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid var(--border)}
  .ok{color:#c6f6d5; border-color:#23543f; background:#0f2b1f}
  .warn{color:#fff1c1; border-color:#5d4a1e; background:#2a2316}
  .bad{color:#ffd1d1; border-color:#553232; background:#2a1717}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .scroll{max-height:360px; overflow:auto; border:1px solid var(--border); border-radius:10px}
  .hscroll{overflow-x:auto;} /* horizontal scroll for small screens */
  .tight th,.tight td{padding:4px 6px}
  .grid{display:grid; gap:8px; grid-template-columns:repeat(4,minmax(0,1fr))}
  .grid-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .grid-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  .footer{margin-top:12px; display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .help{font-size:12px; line-height:1.35}
  .nowrap{white-space:nowrap}

  /* Raw table: wide + readable on phones */
  #rawTbl{ min-width:1500px; }
  #rawTbl thead th{ white-space:nowrap; }

  /* Sticky two-row header for Raw */
  #rawTbl thead tr:first-child th{ top:0; z-index:3; }
  #rawTbl thead tr:nth-child(2) th{ top:28px; z-index:2; }
</style>
</head>
<body>

<h1>FRC REEFSCAPE 2025 — Scouting (Tables-only Web App) + TBA Fetch</h1>
<p class="muted help">Fetch/paste schedule → <b>Raw Data auto-expands</b> (6 rows per match) → checkboxes for booleans, capped counts across Auto+Tele → averages, predictor, planner. Data saves to your browser.</p>

<div class="row">
  <!-- SETTINGS -->
  <section class="card" style="max-width:600px">
    <h2>Settings</h2>
    <table class="tight">
      <tbody>
        <tr><th style="width:45%">Our Team</th>
          <td><input id="ourTeam" type="number" placeholder="e.g., 1234" /></td></tr>
        <tr><th>Decay Factor (weighted avg)</th>
          <td><input id="decay" type="number" step="0.01" min="0" max="1" value="0.85"/></td></tr>
        <tr><th>Max Matches in Schedule</th>
          <td><input id="maxMatches" type="number" value="200"/></td></tr>
      </tbody>
    </table>

    <h3>Per-Robot Max Caps (enforced per row)</h3>
    <table class="tight">
      <tbody>
        <tr><th>Max Coral L1</th><td><input id="capL1" type="number" value="6"/></td></tr>
        <tr><th>Max Coral L2</th><td><input id="capL2" type="number" value="6"/></td></tr>
        <tr><th>Max Coral L3</th><td><input id="capL3" type="number" value="6"/></td></tr>
        <tr><th>Max Coral L4</th><td><input id="capL4" type="number" value="6"/></td></tr>
        <tr><th>Max Algae → Processor</th><td><input id="capAlgP" type="number" value="6"/></td></tr>
        <tr><th>Max Algae → Net</th><td><input id="capAlgN" type="number" value="6"/></td></tr>
      </tbody>
    </table>

    <h3>RP Thresholds</h3>
    <table class="tight">
      <tbody>
        <tr><th>Coral per Level</th><td><input id="rpCoralPerLevel" type="number" value="7"/></td></tr>
        <tr><th>Levels Required (no Coop)</th><td><input id="rpLevels" type="number" value="4"/></td></tr>
        <tr><th>Levels Required (with Coop)</th><td><input id="rpLevelsCoop" type="number" value="3"/></td></tr>
        <tr><th>Barge RP Points</th><td><input id="rpBargePts" type="number" value="16"/></td></tr>
      </tbody>
    </table>

    <div class="footer">
      <button id="saveCfg">Save settings</button>
      <span class="muted">Autosaves too.</span>
    </div>
    <hr/>
    <h3>Import / Export</h3>
    <div class="footer">
      <button id="exportJson">Export JSON</button>
      <label class="ghost pill">
        <input id="importFile" type="file" accept="application/json" style="display:none"/>
        <span class="mono">Import JSON…</span>
      </label>
      <button id="clearStorage" class="secondary">Clear localStorage</button>
    </div>
  </section>

  <!-- RULES + STRATEGY -->
  <section class="card">
    <h2>Rules (REEFSCAPE 2025)</h2>
    <div class="scroll">
      <table id="rulesTbl">
        <thead><tr><th>Item</th><th>Auto</th><th>Tele</th><th>Notes</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
    <h3>Strategy Weights & Reliability Map</h3>
    <table class="tight" id="weightsTbl">
      <tbody>
        <tr><th style="width:45%">Auto Points Weight</th><td><input id="wAuto" type="number" step="0.1" value="1"/></td></tr>
        <tr><th>Teleop Points Weight</th><td><input id="wTele" type="number" step="0.1" value="1"/></td></tr>
        <tr><th>Endgame Points Weight</th><td><input id="wEnd" type="number" step="0.1" value="1"/></td></tr>
        <tr><th>Foul Impact Weight</th><td><input id="wFoul" type="number" step="0.1" value="1"/></td></tr>
        <tr><th>Reliability Floor</th><td><input id="relFloor" type="number" step="0.05" value="0.8"/></td></tr>
        <tr><th>Reliability Ceil</th><td><input id="relCeil" type="number" step="0.05" value="1.2"/></td></tr>
      </tbody>
    </table>
    <div class="footer">
      <button id="saveWeights">Save weights</button>
    </div>
  </section>
</div>

<!-- SCHEDULE -->
<section class="card">
  <h2>Schedule (Fetch from TBA or Copy & Paste)</h2>

  <!-- TBA Fetch Controls -->
  <div class="grid-3">
    <div>
      <label class="muted">Event Key</label>
      <input id="tbaEventKey" placeholder="e.g. 2025nyny" />
    </div>
    <div>
      <label class="muted">Match # (optional filter)</label>
      <input id="tbaMatchFilter" type="number" min="1" placeholder="e.g. 33" />
    </div>
    <div>
      <label class="muted">TBA API Key (stored only in this browser)</label>
      <input id="tbaKey" type="password" placeholder="paste X-TBA-Auth-Key" />
    </div>
  </div>
  <div class="footer">
    <button id="saveTBAKey">Save Key</button>
    <button id="fetchFromTBA">Fetch from TBA</button>
    <button id="importTBAJson" class="ghost">Import TBA JSON…</button>
    <input id="importTBAFile" type="file" accept="application/json" hidden />
    <small class="muted">Endpoint: <span class="mono">/api/v3/event/{event_key}/matches/simple</span></small>
  </div>

  <hr/>

  <p class="help">Or paste rows with headers: <span class="mono">Event | CompLevel | Set | Match | Time | Red1 | Red2 | Red3 | Blue1 | Blue2 | Blue3</span></p>
  <div class="grid-2">
    <textarea id="schedulePaste" placeholder="Paste schedule rows here…"></textarea>
    <div>
      <div class="footer">
        <button id="parseSchedule">Parse Schedule</button>
        <button id="clearSchedule" class="secondary">Clear</button>
        <button id="exportSchedule" class="ghost">Export CSV</button>
      </div>
      <p class="muted help">After parsing or fetching, the app builds <b>Schedule</b> + <b>Raw Data</b> (auto-expanded, editable per team per match).</p>
    </div>
  </div>
  <div class="scroll" style="margin-top:10px">
    <table id="scheduleTbl">
      <thead><tr>
        <th>Event</th><th>CompLvl</th><th>Set</th><th>Match</th><th>Time</th>
        <th>Red1</th><th>Red2</th><th>Red3</th><th>Blue1</th><th>Blue2</th><th>Blue3</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- SCHEDULE EXPANDED (read-only) -->
<section class="card">
  <h2>Schedule Expanded (6 rows per match)</h2>
  <div class="scroll">
    <table id="schedExpTbl">
      <thead><tr>
        <th>Event</th><th>CompLvl</th><th>Set</th><th>Match</th><th>Time</th><th>Alliance</th><th>Team</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- RAW DATA (auto-expanded; editable stats only) -->
<section class="card">
  <h2>Raw Data (Auto-expanded from Schedule)</h2>
  <p class="help">Each row = one robot in one match. Edit the scouting cells (checkboxes + counts). Event/Comp/Match/Team/Alliance come from schedule.</p>
  <div class="footer">
    <button id="exportRaw" class="ghost">Export CSV</button>
  </div>
  <div class="scroll hscroll">
    <table id="rawTbl">
      <thead><tr id="rawHead"></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- PIT SCOUTING -->
<section class="card">
  <h2>Pit Scouting</h2>
  <p class="help">Reliability (1–5) maps to factor using floor/ceil in Strategy Weights.</p>
  <div class="footer">
    <button id="addPitRow" class="ghost">Add Row</button>
    <button id="exportPit" class="ghost">Export CSV</button>
  </div>
  <div class="scroll">
    <table id="pitTbl">
      <thead><tr>
        <th>Team</th><th>Drivetrain</th><th>Max Coral Level</th><th>Auto Coral (Y/N)</th>
        <th>Cage Capability</th><th>Alg → Processor (Y/N)</th><th>Alg → Net (Y/N)</th>
        <th>Reliability (1–5)</th><th>Notes</th><th>ReliabilityFactor</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- TEAM AVERAGES -->
<section class="card">
  <h2>Team Averages (Simple)</h2>
  <div class="footer">
    <button id="recompute">Recompute</button>
  </div>
  <div class="scroll">
    <table id="avgTbl">
      <thead><tr id="avgHead"></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- WEIGHTED AVERAGES -->
<section class="card">
  <h2>Weighted Averages (Recent-weighted)</h2>
  <div class="scroll">
    <table id="wavgTbl">
      <thead><tr id="wavgHead"></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- MATCH PREDICTOR / DASHBOARD -->
<section class="card">
  <h2>Match Predictor & RP Checks</h2>
  <div class="grid-3">
    <table class="tight">
      <tbody>
        <tr><th>Pick schedule match #</th>
          <td>
            <select id="pickMatch"><option value="">—</option></select>
          </td></tr>
        <tr><th>or enter teams (Red)</th>
          <td class="grid-3"><input id="r1" type="number" placeholder="Red1"/><input id="r2" type="number" placeholder="Red2"/><input id="r3" type="number" placeholder="Red3"/></td></tr>
        <tr><th>enter teams (Blue)</th>
          <td class="grid-3"><input id="b1" type="number" placeholder="Blue1"/><input id="b2" type="number" placeholder="Blue2"/><input id="b3" type="number" placeholder="Blue3"/></td></tr>
      </tbody>
    </table>
    <table>
      <thead><tr><th>Totals</th><th>Red</th><th>Blue</th></tr></thead>
      <tbody>
        <tr><td>Simple</td><td id="predRedSimple">—</td><td id="predBlueSimple">—</td></tr>
        <tr><td>Weighted</td><td id="predRedWeighted">—</td><td id="predBlueWeighted">—</td></tr>
        <tr><td>Custom + Reliability</td><td id="predRedCustom">—</td><td id="predBlueCustom">—</td></tr>
      </tbody>
    </table>
    <table>
      <thead><tr><th>RP Checks (approx)</th><th>Red</th></tr></thead>
      <tbody>
        <tr><td>AUTO RP?</td><td id="rpAuto">—</td></tr>
        <tr><td>CORAL RP?</td><td id="rpCoral">—</td></tr>
        <tr><td>BARGE RP?</td><td id="rpBarge">—</td></tr>
        <tr><td>Coop Bonus likely?</td><td id="rpCoop">—</td></tr>
      </tbody>
    </table>
  </div>
</section>

<!-- SCOUT PLANNER -->
<section class="card">
  <h2>Scout Planner</h2>
  <div class="row">
    <div class="card" style="min-width:360px">
      <h3>Our Matches</h3>
      <div class="scroll">
        <table id="ourMatchesTbl">
          <thead><tr><th>Match</th><th>Alliance</th><th>Partners</th><th>Opponents</th><th>Time</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
    <div class="card" style="min-width:360px">
      <h3>Priority Teams to Scout</h3>
      <div class="scroll">
        <table id="priorityTbl">
          <thead><tr><th>Team</th><th>First Shared Match</th><th>Role vs Us</th><th>Scouted Rows</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <h3>Opponents by Match (coverage gaps)</h3>
      <div class="scroll">
        <table id="oppChecklistTbl">
          <thead><tr><th>Match</th><th>Opp1</th><th>Opp2</th><th>Opp3</th><th>Gaps</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
    <!-- REPLACED CARD: Other Matches to Scout -->
    <div class="card" style="min-width:360px">
      <h3>Other Matches to Scout</h3>
      <p class="muted help">Matches that don’t include us but do include teams we face. Highlighted teams are the opponents we face.</p>
      <div class="scroll">
        <table id="otherMatchesTbl">
          <thead>
            <tr>
              <th>Match</th>
              <th>Teams (highlighted = opponents we face)</th>
              <th>Important Teams</th>
              <th>Count</th>
              <th>Time</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>
</section>

<script>
/* =========================
   Data model & persistence
   ========================= */
const state = {
  config: {
    ourTeam: "",
    decay: 0.85,
    maxMatches: 200,
    caps: { L1:6, L2:6, L3:6, L4:6, AlgP:6, AlgN:6 },
    rp: { coralPerLevel:7, levels:4, levelsCoop:3, bargePts:16 }
  },
  weights: { wAuto:1, wTele:1, wEnd:1, wFoul:1, relFloor:0.8, relCeil:1.2 },
  rules: [
    { item:"LEAVE", auto:3, tele:0, notes:"AUTO mobility" },
    { item:"CORAL L1 (trough)", auto:3, tele:2, notes:"" },
    { item:"CORAL L2", auto:4, tele:3, notes:"" },
    { item:"CORAL L3", auto:6, tele:4, notes:"" },
    { item:"CORAL L4", auto:7, tele:5, notes:"" },
    { item:"ALGAE in PROCESSOR", auto:6, tele:6, notes:"same value" },
    { item:"ALGAE in NET", auto:4, tele:4, notes:"same value" },
    { item:"PARK", auto:0, tele:2, notes:"endgame" },
    { item:"CAGE SHALLOW", auto:0, tele:6, notes:"endgame" },
    { item:"CAGE DEEP", auto:0, tele:12, notes:"endgame" },
    { item:"MINOR FOUL (opp +2)", auto:0, tele:2, notes:"opponent gets points" },
    { item:"MAJOR FOUL (opp +6)", auto:0, tele:6, notes:"opponent gets points" },
  ],
  schedule: [],           // [{event,comp,set,match,time,red:[...],blue:[...]}]
  scheduleExpanded: [],   // [{event,comp,set,match,time,alliance,team}]
  raw: [],                // one row per team per match
  pit: [],
  tba: { key: "", lastEventKey: "" }
};

// localStorage
const LS_KEY = "reefscape2025_scout";
function saveAll(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
function loadAll(){
  const s = localStorage.getItem(LS_KEY); if (!s) return;
  try { Object.assign(state, JSON.parse(s)); } catch(e){}
}

/* Utils */
const qs = sel => document.querySelector(sel);
function csvEscape(v){ if(v==null) return ""; v = String(v); return /[,"\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v; }
function toCSV(rows){
  if(!rows.length) return "";
  const keys = Object.keys(rows[0]);
  return [keys.join(","), ...rows.map(r=>keys.map(k=>csvEscape(r[k])).join(","))].join("\n");
}
function download(filename, text){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([text], {type:"text/plain"}));
  a.download = filename; a.click(); URL.revokeObjectURL(a.href);
}
function uniq(arr){ return [...new Set(arr)]; }
function sum(arr){ return arr.reduce((a,b)=>a+(+b||0),0); }
function avg(arr){ const v=arr.filter(x=>x!=="" && x!=null); return v.length? sum(v)/v.length : 0; }
function asInt(v){ const n = parseInt(v,10); return isFinite(n)? n : 0; }
function asNum(v){ const n = Number(v); return isFinite(n)? n : 0; }
function mkRow(cols){ const tr=document.createElement("tr"); cols.forEach(c=>{ const td=document.createElement("td"); if(c instanceof Node){ td.appendChild(c);} else {td.innerHTML=c;} tr.appendChild(td); }); return tr; }

/* Render rules & settings */
function renderRules(){
  const tb = qs("#rulesTbl tbody"); tb.innerHTML="";
  state.rules.forEach(r=> tb.appendChild(mkRow([r.item, r.auto, r.tele, r.notes])));
}
function bindSettings(){
  qs("#ourTeam").value = state.config.ourTeam || "";
  qs("#decay").value = state.config.decay;
  qs("#maxMatches").value = state.config.maxMatches;

  qs("#capL1").value = state.config.caps.L1;
  qs("#capL2").value = state.config.caps.L2;
  qs("#capL3").value = state.config.caps.L3;
  qs("#capL4").value = state.config.caps.L4;
  qs("#capAlgP").value = state.config.caps.AlgP;
  qs("#capAlgN").value = state.config.caps.AlgN;

  qs("#rpCoralPerLevel").value = state.config.rp.coralPerLevel;
  qs("#rpLevels").value = state.config.rp.levels;
  qs("#rpLevelsCoop").value = state.config.rp.levelsCoop;
  qs("#rpBargePts").value = state.config.rp.bargePts;

  qs("#wAuto").value = state.weights.wAuto;
  qs("#wTele").value = state.weights.wTele;
  qs("#wEnd").value = state.weights.wEnd;
  qs("#wFoul").value = state.weights.wFoul;
  qs("#relFloor").value = state.weights.relFloor;
  qs("#relCeil").value = state.weights.relCeil;

  qs("#tbaKey").value = state.tba.key || "";
  qs("#tbaEventKey").value = state.tba.lastEventKey || "";
}
function saveSettings(){
  state.config.ourTeam = qs("#ourTeam").value.trim();
  state.config.decay = asNum(qs("#decay").value);
  state.config.maxMatches = asInt(qs("#maxMatches").value);

  state.config.caps.L1 = asInt(qs("#capL1").value);
  state.config.caps.L2 = asInt(qs("#capL2").value);
  state.config.caps.L3 = asInt(qs("#capL3").value);
  state.config.caps.L4 = asInt(qs("#capL4").value);
  state.config.caps.AlgP = asInt(qs("#capAlgP").value);
  state.config.caps.AlgN = asInt(qs("#capAlgN").value);

  state.config.rp.coralPerLevel = asInt(qs("#rpCoralPerLevel").value);
  state.config.rp.levels = asInt(qs("#rpLevels").value);
  state.config.rp.levelsCoop = asInt(qs("#rpLevelsCoop").value);
  state.config.rp.bargePts = asInt(qs("#rpBargePts").value);
  saveAll(); recomputeEverything();
}
function saveWeights(){
  state.weights.wAuto = asNum(qs("#wAuto").value);
  state.weights.wTele = asNum(qs("#wTele").value);
  state.weights.wEnd  = asNum(qs("#wEnd").value);
  state.weights.wFoul = asNum(qs("#wFoul").value);
  state.weights.relFloor = asNum(qs("#relFloor").value);
  state.weights.relCeil  = asNum(qs("#relCeil").value);
  saveAll(); recomputeEverything();
}

/* TBA Fetch + Import JSON */
function normalizeFromTBA(json, eventKey){
  return json.map(m => ({
    event: eventKey || (m.event_key||""),
    comp: m.comp_level || "",
    set: m.set_number || 1,
    match: m.match_number || 0,
    time: m.time || m.predicted_time || m.actual_time || "",
    red:[(m.alliances?.red?.team_keys?.[0]||"").replace("frc",""),
         (m.alliances?.red?.team_keys?.[1]||"").replace("frc",""),
         (m.alliances?.red?.team_keys?.[2]||"").replace("frc","")].map(asInt),
    blue:[(m.alliances?.blue?.team_keys?.[0]||"").replace("frc",""),
          (m.alliances?.blue?.team_keys?.[1]||"").replace("frc",""),
          (m.alliances?.blue?.team_keys?.[2]||"").replace("frc","")].map(asInt)
  })).sort((a,b)=> (a.comp||"").localeCompare(b.comp||"") || a.match-b.match)
    .slice(0, state.config.maxMatches);
}
async function fetchFromTBA(){
  const key = (qs("#tbaKey").value || state.tba.key || "").trim();
  const eventKey = (qs("#tbaEventKey").value || "").trim();
  const matchFilter = asInt(qs("#tbaMatchFilter").value);
  if(!key){ alert("Enter your TBA API key."); return; }
  if(!eventKey){ alert("Enter an event key (e.g., 2025nyny)."); return; }
  try{
    const url = `https://www.thebluealliance.com/api/v3/event/${encodeURIComponent(eventKey)}/matches/simple`;
    const res = await fetch(url, { headers: { "X-TBA-Auth-Key": key }});
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    let data = await res.json();
    if(matchFilter>0) data = data.filter(m => asInt(m.match_number)===matchFilter);
    state.schedule = normalizeFromTBA(data, eventKey);
    state.tba.lastEventKey = eventKey;
    onScheduleUpdated();
  }catch(err){ alert("Fetch failed: " + err.message); }
}
qs("#saveTBAKey").onclick = ()=>{ state.tba.key = qs("#tbaKey").value.trim(); saveAll(); alert("Saved TBA key to this browser."); };
qs("#fetchFromTBA").onclick = fetchFromTBA;
qs("#importTBAJson").onclick = ()=> qs("#importTBAFile").click();
qs("#importTBAFile").onchange = async (e)=>{
  const f = e.target.files?.[0]; if(!f) return;
  try{
    const json = JSON.parse(await f.text());
    const eventKey = qs("#tbaEventKey").value.trim();
    const matchFilter = asInt(qs("#tbaMatchFilter").value);
    let data = Array.isArray(json)? json : [];
    if(matchFilter>0) data = data.filter(m => asInt(m.match_number)===matchFilter);
    state.schedule = normalizeFromTBA(data, eventKey);
    onScheduleUpdated();
  }catch{ alert("Invalid JSON."); }
};

/* Schedule parse/paste */
function parseScheduleText(txt){
  const rows = txt.trim().split(/\r?\n/).filter(Boolean);
  const out = [];
  for (const line of rows){
    // CSV-aware split fallback to TSV/whitespace
    let parts = line.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/).map(s=>s.replace(/^"(.*)"$/,'$1').trim());
    if (parts.length < 11){ parts = line.split(/\t|\s{2,}/).map(s=>s.trim()); }
    if (parts.length < 11) continue;
    const [event,comp,set,match,time, r1,r2,r3, b1,b2,b3] = parts;
    out.push({
      event, comp, set:asInt(set), match:asInt(match), time,
      red:[r1,r2,r3].map(asInt), blue:[b1,b2,b3].map(asInt)
    });
  }
  out.sort((a,b)=> (a.comp||"").localeCompare(b.comp||"") || a.match-b.match);
  return out.slice(0, state.config.maxMatches);
}
function renderSchedule(){
  const tb = qs("#scheduleTbl tbody"); tb.innerHTML="";
  const matchSelect = qs("#pickMatch"); matchSelect.innerHTML = `<option value="">—</option>`;
  state.schedule.forEach(m=>{
    tb.appendChild(mkRow([m.event,m.comp,m.set,m.match,m.time, ...m.red, ...m.blue]));
    if (m.comp && m.comp.toLowerCase().startsWith("qm")){
      const opt = document.createElement("option");
      opt.value=String(m.match); opt.textContent = m.match;
      matchSelect.appendChild(opt);
    }
  });
}
function expandSchedule(){
  const rows = [];
  for (const m of state.schedule){
    const base = {event:m.event, comp:m.comp, set:m.set, match:m.match, time:m.time};
    for (let i=0;i<3;i++) rows.push({...base, alliance:"Red", team: m.red[i]||""});
    for (let i=0;i<3;i++) rows.push({...base, alliance:"Blue", team: m.blue[i]||""});
  }
  state.scheduleExpanded = rows;
}
function renderSchedExpanded(){
  const tb = qs("#schedExpTbl tbody"); tb.innerHTML="";
  state.scheduleExpanded.forEach(r=> tb.appendChild(mkRow([r.event,r.comp,r.set,r.match,r.time,r.alliance,r.team])));
}
function onScheduleUpdated(){
  expandSchedule();
  renderSchedule();
  renderSchedExpanded();
  buildRawFromSchedule(true);   // merge existing by (Comp|Match|Team)
  renderRaw();
  renderSchedulePicklist();
  renderPlanner();
  recomputeEverything();
  saveAll();
}

/* ======== RAW DATA (auto from schedule; one row per team/match) ======== */
const RAW_HEADERS = [
  "Event","Comp","Match","Team","Alliance",
  "AUTO Leave",
  "AUTO: L1","AUTO: L2","AUTO: L3","AUTO: L4",
  "AUTO: Alg→Proc","AUTO: Alg→Net",
  "TELE: L1","TELE: L2","TELE: L3","TELE: L4",
  "TELE: Alg→Proc","TELE: Alg→Net",
  "END: Park","END: Shallow","END: Deep",
  "Fouls: Minor","Fouls: Major",
  "Notes",
  "AUTO Pts","TELE Pts","END Pts","TOTAL","Opp Pts From Fouls"
];

function renderRawHeaders(){
  const thead = document.querySelector("#rawTbl thead");
  thead.innerHTML = "";

  const cat = document.createElement("tr");
  [
    ["",5],
    ["AUTO",7],
    ["TELEOP",6],
    ["ENDGAME",3],
    ["FOULS",2],
    ["NOTES",1],
    ["POINTS",5]
  ].forEach(([label,span])=>{
    const th=document.createElement("th");
    th.textContent = label;
    th.colSpan = span;
    cat.appendChild(th);
  });
  thead.appendChild(cat);

  const detail = document.createElement("tr");
  const cols = [
    "Event","Comp","Match","Team","Alliance",
    "Leave (Auto)","L1 Auto","L2 Auto","L3 Auto","L4 Auto","Alg→Proc Auto","Alg→Net Auto",
    "L1 Tele","L2 Tele","L3 Tele","L4 Tele","Alg→Proc Tele","Alg→Net Tele",
    "Park","Shallow","Deep",
    "Minor","Major",
    "Notes",
    "Auto Pts","Tele Pts","End Pts","Total","Opp Pts (Fouls)"
  ];
  cols.forEach(h=>{ const th=document.createElement("th"); th.textContent=h; detail.appendChild(th); });
  thead.appendChild(detail);
}

// Build key to merge raw rows across schedule updates
function rawKey(comp, match, team){ return `${comp}|${match}|${team}`; }
function defaultRawFor(expRow){
  const r = {};
  RAW_HEADERS.forEach(h=>{
    if (["AUTO Leave","END: Park","END: Shallow","END: Deep"].includes(h)) r[h]=0;
    else r[h]="";
  });
  r.Event = expRow.event; r.Comp = expRow.comp; r.Match = expRow.match; r.Team = expRow.team; r.Alliance = expRow.alliance;
  r["Fouls: Minor"]=0; r["Fouls: Major"]=0;
  r["AUTO: L1"]=0; r["AUTO: L2"]=0; r["AUTO: L3"]=0; r["AUTO: L4"]=0;
  r["AUTO: Alg→Proc"]=0; r["AUTO: Alg→Net"]=0;
  r["TELE: L1"]=0; r["TELE: L2"]=0; r["TELE: L3"]=0; r["TELE: L4"]=0;
  r["TELE: Alg→Proc"]=0; r["TELE: Alg→Net"]=0;
  r["AUTO Pts"]=0; r["TELE Pts"]=0; r["END Pts"]=0; r["TOTAL"]=0; r["Opp Pts From Fouls"]=0;
  return r;
}
function buildRawFromSchedule(merge=true){
  const map = new Map();
  if (merge){
    for (const r of state.raw){
      map.set(rawKey(r.Comp, r.Match, r.Team), r);
    }
  }
  const newRows = [];
  for (const ex of state.scheduleExpanded){
    const key = rawKey(ex.comp, ex.match, ex.team);
    if (map.has(key)){
      const existing = map.get(key);
      existing.Event = ex.event; existing.Comp = ex.comp; existing.Match = ex.match; existing.Team = ex.team; existing.Alliance = ex.alliance;
      computePointsForRow(existing);
      newRows.push(existing);
    }else{
      const r = defaultRawFor(ex);
      computePointsForRow(r);
      newRows.push(r);
    }
  }
  state.raw = newRows;
  saveAll();
}

// Caps & clamping across Auto+Tele
function clampCounts(row, changedKey){
  const C = state.config.caps;
  const pairClamp = (aKey, bKey, cap)=>{
    let a = asInt(row[aKey]||0), b = asInt(row[bKey]||0);
    if (a+b > cap){
      if (changedKey === aKey) a = Math.max(0, cap - b);
      else b = Math.max(0, cap - a);
    }
    row[aKey]=a; row[bKey]=b;
  };
  pairClamp("AUTO: L1","TELE: L1", C.L1);
  pairClamp("AUTO: L2","TELE: L2", C.L2);
  pairClamp("AUTO: L3","TELE: L3", C.L3);
  pairClamp("AUTO: L4","TELE: L4", C.L4);
  pairClamp("AUTO: Alg→Proc","TELE: Alg→Proc", C.AlgP);
  pairClamp("AUTO: Alg→Net","TELE: Alg→Net", C.AlgN);
}
// Endgame exclusivity
function exclusiveEndgame(row, picked){
  if (picked==="END: Park"){ row["END: Shallow"]=0; row["END: Deep"]=0; }
  if (picked==="END: Shallow"){ row["END: Park"]=0; row["END: Deep"]=0; }
  if (picked==="END: Deep"){ row["END: Park"]=0; row["END: Shallow"]=0; }
}

// Points rules
const RULE = {
  LEAVE: {auto:3, tele:0},
  L1: {auto:3, tele:2},
  L2: {auto:4, tele:3},
  L3: {auto:6, tele:4},
  L4: {auto:7, tele:5},
  ALG_PROC: {auto:6, tele:6},
  ALG_NET: {auto:4, tele:4},
  PARK: {auto:0, tele:2},
  CAGE_SH: {auto:0, tele:6},
  CAGE_DP: {auto:0, tele:12}
};
function computePointsForRow(r){
  const n = k => asNum(r[k]||0);
  const auto = (r["AUTO Leave"]?1:0)*RULE.LEAVE.auto
             + n("AUTO: L1")*RULE.L1.auto + n("AUTO: L2")*RULE.L2.auto + n("AUTO: L3")*RULE.L3.auto + n("AUTO: L4")*RULE.L4.auto
             + n("AUTO: Alg→Proc")*RULE.ALG_PROC.auto + n("AUTO: Alg→Net")*RULE.ALG_NET.auto;
  const tele = n("TELE: L1")*RULE.L1.tele + n("TELE: L2")*RULE.L2.tele + n("TELE: L3")*RULE.L3.tele + n("TELE: L4")*RULE.L4.tele
             + n("TELE: Alg→Proc")*RULE.ALG_PROC.tele + n("TELE: Alg→Net")*RULE.ALG_NET.tele;
  const endp = (r["END: Park"]?1:0)*RULE.PARK.tele
             + (r["END: Shallow"]?1:0)*RULE.CAGE_SH.tele
             + (r["END: Deep"]?1:0)*RULE.CAGE_DP.tele;
  r["AUTO Pts"]=auto; r["TELE Pts"]=tele; r["END Pts"]=endp;
  r["TOTAL"]=auto+tele+endp;
  r["Opp Pts From Fouls"] = 2*n("Fouls: Minor") + 6*n("Fouls: Major");
}

// Inputs
function inputText(value, on){ const i=document.createElement("input"); i.value=value??""; i.onchange=e=>on(e.target.value); return i; }
function inputNum(value, on){ const i=document.createElement("input"); i.type="number"; i.step="1"; i.value=(value==null||value==="")?"":Number(value); i.onchange=e=>on(e.target.value); return i; }
function inputCheckbox(checked, on){
  const i=document.createElement("input"); i.type="checkbox"; i.checked=!!checked;
  i.onchange=e=> on(e.target.checked?1:0); return i;
}

// Render Raw table
function renderRawHeadersAndBody(){
  renderRawHeaders();
  renderRaw();
}
function renderRaw(){
  const tb = qs("#rawTbl tbody"); tb.innerHTML="";
  state.raw.forEach((row)=>{
    const cells=[];

    // Fixed schedule fields (read-only text)
    cells.push(`<span class="mono">${row.Event||""}</span>`);
    cells.push(`<span class="mono">${row.Comp||""}</span>`);
    cells.push(`<span class="mono">${row.Match||""}</span>`);
    cells.push(`<span class="mono">${row.Team||""}</span>`);
    cells.push(`<span class="mono">${row.Alliance||""}</span>`);

    // Booleans as checkboxes
    cells.push(inputCheckbox(row["AUTO Leave"], v=>{ row["AUTO Leave"]=v; computePointsForRow(row); saveAll(); renderRaw(); }));

    // Counted fields with caps across Auto+Tele
    const cappedNum = (key)=> inputNum(row[key], v=>{
      row[key]=asInt(v); clampCounts(row, key); computePointsForRow(row); saveAll(); renderRaw();
    });

    ["AUTO: L1","AUTO: L2","AUTO: L3","AUTO: L4",
     "AUTO: Alg→Proc","AUTO: Alg→Net",
     "TELE: L1","TELE: L2","TELE: L3","TELE: L4",
     "TELE: Alg→Proc","TELE: Alg→Net"].forEach(k=> cells.push(cappedNum(k)));

    // Endgame (mutually exclusive) as checkboxes
    const endBox = (k)=> inputCheckbox(row[k], v=>{
      row[k]=v; if(v) exclusiveEndgame(row,k); computePointsForRow(row); saveAll(); renderRaw();
    });
    cells.push(endBox("END: Park"));
    cells.push(endBox("END: Shallow"));
    cells.push(endBox("END: Deep"));

    // Fouls numeric
    cells.push(inputNum(row["Fouls: Minor"], v=>{ row["Fouls: Minor"]=asInt(v); computePointsForRow(row); saveAll(); renderRaw(); }));
    cells.push(inputNum(row["Fouls: Major"], v=>{ row["Fouls: Major"]=asInt(v); computePointsForRow(row); saveAll(); renderRaw(); }));

    // Notes
    cells.push(inputText(row["Notes"]||"", v=>{ row["Notes"]=v; saveAll(); }));

    // Computed points (read-only)
    ["AUTO Pts","TELE Pts","END Pts","TOTAL","Opp Pts From Fouls"].forEach(h=>{
      cells.push(`<span class="mono">${Number(row[h]||0).toFixed(0)}</span>`);
    });

    tb.appendChild(mkRow(cells));
  });
}

/* Pit scouting */
function reliabilityFactor(team){
  const t = asInt(team);
  const row = state.pit.find(x=>asInt(x.Team)===t);
  if (!row) return 1;
  const rel = asInt(row.Reliability||0);
  const f = state.weights.relFloor, c = state.weights.relCeil;
  if (!rel) return 1;
  return f + (rel-1)*(c-f)/4;
}
function renderPit(){
  const tb = qs("#pitTbl tbody"); tb.innerHTML="";
  const optsDT = ["","Swerve","Tank","West Coast","Mecanum","Other"];
  const optsLvl = ["","L1","L2","L3","L4"];
  const optsYN = ["","Y","N"];
  const optsCage = ["","None","Park","Shallow","Deep"];
  state.pit.forEach((r)=>{
    const mkSel = (arr,val,onchange)=>{ const s=document.createElement("select"); arr.forEach(x=>{const o=document.createElement("option");o.value=x;o.textContent=x;s.appendChild(o);}); s.value=val||""; s.onchange=onchange; return s; };
    const mkInp = (val,on)=>{ const i=document.createElement("input"); i.value=val||""; i.onchange=on; return i; };
    const mkNum = (val,on)=>{ const i=document.createElement("input"); i.type="number"; i.min="1"; i.max="5"; i.step="1"; i.value=val||""; i.onchange=on; return i; };

    const rel = reliabilityFactor(r.Team);
    const tr = mkRow([
      mkInp(r.Team, e=>{r.Team=asInt(e.target.value); saveAll();}),
      mkSel(optsDT, r.Drivetrain, e=>{r.Drivetrain=e.target.value; saveAll();}),
      mkSel(optsLvl, r.MaxCoralLevel, e=>{r.MaxCoralLevel=e.target.value; saveAll();}),
      mkSel(optsYN, r.AutoCoral, e=>{r.AutoCoral=e.target.value; saveAll();}),
      mkSel(optsCage, r.CageCap, e=>{r.CageCap=e.target.value; saveAll();}),
      mkSel(optsYN, r.AlgProc, e=>{r.AlgProc=e.target.value; saveAll();}),
      mkSel(optsYN, r.AlgNet, e=>{r.AlgNet=e.target.value; saveAll();}),
      mkNum(r.Reliability, e=>{r.Reliability=asInt(e.target.value); saveAll(); renderPit();}),
      mkInp(r.Notes, e=>{r.Notes=e.target.value; saveAll();}),
      `<span class="pill ${rel>=1?'ok':'warn'} mono">${rel.toFixed(2)}</span>`
    ]);
    tb.appendChild(tr);
  });
}
qs("#addPitRow").onclick = ()=>{ state.pit.push({Team:""}); renderPit(); saveAll(); };

/* Averages */
const AVG_HEADERS = [
  "Team","Matches",
  "AUTO Leave","AUTO L1","AUTO L2","AUTO L3","AUTO L4",
  "AUTO AlgProc","AUTO AlgNet",
  "TELE L1","TELE L2","TELE L3","TELE L4",
  "TELE AlgProc","TELE AlgNet",
  "END Park","END Shallow","END Deep",
  "Avg AUTO","Avg TELE","Avg END","Avg TOTAL","Avg FOUL to Opp"
];
function renderAvgHeaders(){
  const tr = qs("#avgHead"); tr.innerHTML="";
  AVG_HEADERS.forEach(h=>{const th=document.createElement("th"); th.textContent=h; tr.appendChild(th);});
  const trW = qs("#wavgHead"); trW.innerHTML="";
  AVG_HEADERS.forEach(h=>{const th=document.createElement("th"); th.textContent=(h==="Avg TOTAL"?"Wgt TOTAL":h.replace("Avg ","Wgt ")); trW.appendChild(th);});
}
function groupRowsByTeam(){
  const map = new Map();
  for (const r of state.raw){
    const t = String(r.Team||"").trim(); if (!t) continue;
    if (!map.has(t)) map.set(t, []);
    map.get(t).push(r);
  }
  return map;
}
function computeSimpleAverages(){
  const map = groupRowsByTeam();
  const rows = [];
  for (const [team, arr] of map.entries()){
    const getA = k => avg(arr.map(r=>asNum(r[k])));
    const matches = arr.length;
    rows.push({
      Team:team, Matches:matches,
      "AUTO Leave":getA("AUTO Leave"),
      "AUTO L1":getA("AUTO: L1"),"AUTO L2":getA("AUTO: L2"),"AUTO L3":getA("AUTO: L3"),"AUTO L4":getA("AUTO: L4"),
      "AUTO AlgProc":getA("AUTO: Alg→Proc"), "AUTO AlgNet":getA("AUTO: Alg→Net"),
      "TELE L1":getA("TELE: L1"),"TELE L2":getA("TELE: L2"),"TELE L3":getA("TELE: L3"),"TELE L4":getA("TELE: L4"),
      "TELE AlgProc":getA("TELE: Alg→Proc"), "TELE AlgNet":getA("TELE: Alg→Net"),
      "END Park":getA("END: Park"), "END Shallow":getA("END: Shallow"), "END Deep":getA("END: Deep"),
      "Avg AUTO":avg(arr.map(r=>r["AUTO Pts"])), "Avg TELE":avg(arr.map(r=>r["TELE Pts"])), "Avg END":avg(arr.map(r=>r["END Pts"])),
      "Avg TOTAL":avg(arr.map(r=>r["TOTAL"])), "Avg FOUL to Opp":avg(arr.map(r=>r["Opp Pts From Fouls"]))
    });
  }
  rows.sort((a,b)=>asInt(a.Team)-asInt(b.Team));
  return rows;
}
function latestMatchPerTeam(arr){ return arr.reduce((m,r)=>Math.max(m, asInt(r.Match)||0), 0); }
function computeWeightedAverages(decay){
  const map = groupRowsByTeam();
  const rows = [];
  for (const [team, arr] of map.entries()){
    const latest = latestMatchPerTeam(arr);
    const w = r => Math.pow(decay, Math.max(0, latest - (asInt(r.Match)||0)));
    const wavg = key => {
      let num=0,den=0;
      for (const r of arr){ const val=asNum(r[key]); const wt=w(r); if(isFinite(val)){ num+=val*wt; den+=wt; } }
      return den? num/den : 0;
    };
    rows.push({
      Team:team, Matches:arr.length,
      "AUTO Leave":wavg("AUTO Leave"),
      "AUTO L1":wavg("AUTO: L1"),"AUTO L2":wavg("AUTO: L2"),"AUTO L3":wavg("AUTO: L3"),"AUTO L4":wavg("AUTO: L4"),
      "AUTO AlgProc":wavg("AUTO: Alg→Proc"), "AUTO AlgNet":wavg("AUTO: Alg→Net"),
      "TELE L1":wavg("TELE: L1"),"TELE L2":wavg("TELE: L2"),"TELE L3":wavg("TELE: L3"),"TELE L4":wavg("TELE: L4"),
      "TELE AlgProc":wavg("TELE: Alg→Proc"), "TELE AlgNet":wavg("TELE: Alg→Net"),
      "END Park":wavg("END: Park"), "END Shallow":wavg("END: Shallow"), "END Deep":wavg("END: Deep"),
      "Avg AUTO":wavg("AUTO Pts"), "Avg TELE":wavg("TELE Pts"), "Avg END":wavg("END Pts"),
      "Wgt TOTAL":wavg("TOTAL"), "Avg FOUL to Opp":wavg("Opp Pts From Fouls")
    });
  }
  rows.sort((a,b)=>asInt(a.Team)-asInt(b.Team));
  return rows;
}
function renderTableFromObjects(tblId, rows, headers){
  const tb = qs(`#${tblId} tbody`); tb.innerHTML="";
  rows.forEach(r=>{
    const cols = headers.map(h => (h in r) ? (typeof r[h]==="number" ? r[h].toFixed(2) : r[h]) : "");
    tb.appendChild(mkRow(cols));
  });
}

/* Predictor & Planner */
function indexByTeam(rows){ const m = new Map(); rows.forEach(r => m.set(asInt(r.Team), r)); return m; }
function fetchAllianceTeams(){
  const r = [qs("#r1").value, qs("#r2").value, qs("#r3").value].map(asInt).filter(Boolean);
  const b = [qs("#b1").value, qs("#b2").value, qs("#b3").value].map(asInt).filter(Boolean);
  return {r,b};
}
function sumTeams(rowsIndex, teams, field){
  return sum(teams.map(t => asNum(rowsIndex.get(t)?.[field] || 0)));
}
function coralLevelTotals(rowsIndex, teams){
  const sumField = (f)=>sum(teams.map(t => asNum(rowsIndex.get(t)?.[f]||0)));
  return {
    L1: sumField("AUTO L1")+sumField("TELE L1"),
    L2: sumField("AUTO L2")+sumField("TELE L2"),
    L3: sumField("AUTO L3")+sumField("TELE L3"),
    L4: sumField("AUTO L4")+sumField("TELE L4"),
  };
}
function reliabilityFactorForTeam(team){ return reliabilityFactor(team); }
function computePredictions(){
  const {r,b} = fetchAllianceTeams();
  const simple = computeSimpleAverages(); const sm = indexByTeam(simple);
  const weighted = computeWeightedAverages(state.config.decay); const wm = indexByTeam(weighted);

  qs("#predRedSimple").textContent = sumTeams(sm, r, "Avg TOTAL").toFixed(1);
  qs("#predBlueSimple").textContent = sumTeams(sm, b, "Avg TOTAL").toFixed(1);
  qs("#predRedWeighted").textContent = sumTeams(wm, r, "Wgt TOTAL").toFixed(1);
  qs("#predBlueWeighted").textContent = sumTeams(wm, b, "Wgt TOTAL").toFixed(1);

  const W = state.weights;
  function customFor(team, m){
    const A = asNum(m.get(team)?.["Avg AUTO"]||0);
    const T = asNum(m.get(team)?.["Avg TELE"]||0);
    const E = asNum(m.get(team)?.["Avg END"]||0);
    const F = asNum(m.get(team)?.["Avg FOUL to Opp"]||0);
    const rf = reliabilityFactorForTeam(team);
    return (A*W.wAuto + T*W.wTele + E*W.wEnd - F*W.wFoul) * rf;
    }
  const rC = r.reduce((acc,t)=>acc+customFor(t, sm), 0);
  const bC = b.reduce((acc,t)=>acc+customFor(t, sm), 0);
  qs("#predRedCustom").textContent = rC.toFixed(1);
  qs("#predBlueCustom").textContent = bC.toFixed(1);

  // RP heuristics
  const leaveSum = sumTeams(sm, r, "AUTO Leave");
  const autoCoralAny = (sumTeams(sm, r, "AUTO L1")+sumTeams(sm, r, "AUTO L2")
                      +sumTeams(sm, r, "AUTO L3")+sumTeams(sm, r, "AUTO L4")) > 0 ? "Yes" : "No";
  qs("#rpAuto").textContent = (leaveSum >= 2.5 && autoCoralAny==="Yes") ? "Likely" : "Unlikely/Maybe";

  const C = state.config.rp; const L = coralLevelTotals(sm, r);
  const levels = (L.L1>=C.coralPerLevel) + (L.L2>=C.coralPerLevel) + (L.L3>=C.coralPerLevel) + (L.L4>=C.coralPerLevel);
  qs("#rpCoral").textContent = (levels>=C.levels) ? "Likely (no Coop)" : (levels>=C.levelsCoop ? "Maybe (with Coop)" : "Unlikely");

  const endPts = 2*sumTeams(sm, r, "END Park") + 6*sumTeams(sm, r, "END Shallow") + 12*sumTeams(sm, r, "END Deep");
  qs("#rpBarge").textContent = (endPts >= C.bargePts) ? "Likely" : "Unlikely/Maybe";

  const redProc = sumTeams(sm, r, "AUTO AlgProc")+sumTeams(sm, r, "TELE AlgProc");
  const blueProc = sumTeams(sm, b, "AUTO AlgProc")+sumTeams(sm, b, "TELE AlgProc");
  qs("#rpCoop").textContent = (redProc>=2 && blueProc>=2) ? "Likely" : "Unlikely/Depends";
}

/* Planner */
function renderPlanner(){
  const our = asInt(state.config.ourTeam);
  const ours = state.scheduleExpanded.filter(r=>asInt(r.team)===our);
  const ourMatches = uniq(ours.map(r=>asInt(r.match))).sort((a,b)=>a-b);

  // Our Matches table
  const tb = qs("#ourMatchesTbl tbody"); tb.innerHTML="";
  for (const m of ourMatches){
    const rows = state.scheduleExpanded.filter(r=>asInt(r.match)===m);
    const ourRow = rows.find(r=>asInt(r.team)===our);
    const ourAlliance = ourRow?.alliance || "";
    const partners = rows.filter(r=>r.alliance===ourAlliance && asInt(r.team)!==our).map(r=>r.team).join(", ");
    const opps = rows.filter(r=>r.alliance!==ourAlliance).map(r=>r.team).join(", ");
    const time = (state.schedule.find(x=>asInt(x.match)===m && x.comp===ourRow?.comp)||{}).time || (state.schedule.find(x=>asInt(x.match)===m)||{}).time || "";
    tb.appendChild(mkRow([m, ourAlliance, partners, opps, time]));
  }

  // Priority teams we face + first shared match + scouted rows count
  const teamsWeFace = uniq(
    ourMatches.flatMap(m => state.scheduleExpanded.filter(r=>asInt(r.match)===m && asInt(r.team)!==our).map(r=>asInt(r.team)))
  ).sort((a,b)=>a-b);
  const tb2 = qs("#priorityTbl tbody"); tb2.innerHTML="";
  for (const t of teamsWeFace){
    const firstShared = ourMatches.find(m => state.scheduleExpanded.some(r=>asInt(r.match)===m && asInt(r.team)===t));
    const rowAtMatch = state.scheduleExpanded.find(r=>asInt(r.match)===firstShared && asInt(r.team)===t);
    const ourRowAtMatch = state.scheduleExpanded.find(r=>asInt(r.match)===firstShared && asInt(r.team)===our);
    const role = (rowAtMatch?.alliance === ourRowAtMatch?.alliance) ? "Partner" : "Opponent";
    const scoutedRows = state.raw.filter(r=>asInt(r.Team)===t && asNum(r["TOTAL"])>0).length;
    const chip = scoutedRows>0 ? `<span class="pill ok">${scoutedRows}</span>` : `<span class="pill bad">0</span>`;
    tb2.appendChild(mkRow([t, firstShared??"", role, chip]));
  }

  // Opponents by our match (coverage gaps)
  const tb3 = qs("#oppChecklistTbl tbody"); tb3.innerHTML="";
  for (const m of ourMatches){
    const rows = state.scheduleExpanded.filter(r=>asInt(r.match)===m);
    const ourRow = rows.find(r=>asInt(r.team)===our);
    const opps = rows.filter(r=>r.alliance!==ourRow?.alliance).map(r=>asInt(r.team));
    const gaps = opps.filter(t => state.raw.filter(r=>asInt(r.Team)===t && asNum(r["TOTAL"])>0).length===0);
    const gapCell = gaps.length? `<span class="pill warn mono">${gaps.join(", ")}</span>` : `<span class="pill ok">none</span>`;
    tb3.appendChild(mkRow([m, opps[0]||"", opps[1]||"", opps[2]||"", gapCell]));
  }

  // OTHER MATCHES TO SCOUT (we don't play, but include ≥1 opponent we face)
  (function buildOtherMatchesToScout(){
    const tb = qs("#otherMatchesTbl tbody"); if (!tb) return;
    if (!our) { tb.innerHTML = ""; return; }

    const ourMatchSet = new Set(ourMatches);
    // Collect all opponents we face in our matches
    const opponentsSet = new Set();
    for (const m of ourMatches) {
      const rows = state.scheduleExpanded.filter(r => asInt(r.match) === m);
      const ourRow = rows.find(r => asInt(r.team) === our);
      if (!ourRow) continue;
      for (const r of rows) {
        if (r.alliance !== ourRow.alliance) opponentsSet.add(asInt(r.team));
      }
    }

    // Helper: highlight teams that are opponents we face
    const hi = (t) => opponentsSet.has(asInt(t))
      ? `<span class="pill bad mono">${t}</span>`
      : `<span class="mono">${t}</span>`;

    const candidates = [];
    for (const s of state.schedule) {
      if (ourMatchSet.has(asInt(s.match))) continue; // skip our matches
      const allTeams = [...s.red, ...s.blue].map(asInt);
      const important = allTeams.filter(t => opponentsSet.has(t));
      if (important.length === 0) continue;

      const teamsCell = `R: ${hi(s.red[0])}, ${hi(s.red[1])}, ${hi(s.red[2])} &nbsp; | &nbsp; B: ${hi(s.blue[0])}, ${hi(s.blue[1])}, ${hi(s.blue[2])}`;
      const importantCell = important.map(t => `<span class="pill warn mono">${t}</span>`).join(" ");
      candidates.push({
        match: asInt(s.match),
        comp: s.comp || "",
        count: important.length,
        teamsCell,
        importantCell,
        time: s.time || ""
      });
    }

    // Sort: more important teams first, then by match number
    candidates.sort((a,b) => (b.count - a.count) || (a.match - b.match));

    tb.innerHTML = "";
    for (const c of candidates) {
      const label = `${c.comp} ${c.match}`;
      tb.appendChild(mkRow([label, c.teamsCell, c.importantCell, String(c.count), c.time]));
    }
  })();
}

function renderSchedulePicklist(){
  const sel=qs("#pickMatch");
  const seen=new Set();
  sel.innerHTML='<option value="">—</option>';
  for (const s of state.schedule){
    if (s.comp?.toLowerCase().startsWith("qm") && !seen.has(s.match)){
      const o=document.createElement("option");
      o.value=String(s.match); o.textContent=s.match;
      sel.appendChild(o); seen.add(s.match);
    }
  }
}
qs("#exportSchedule").onclick = ()=>{
  const rows = state.schedule.map(m => ({
    Event:m.event, CompLevel:m.comp, Set:m.set, Match:m.match, Time:m.time,
    Red1:m.red[0], Red2:m.red[1], Red3:m.red[2], Blue1:m.blue[0], Blue2:m.blue[1], Blue3:m.blue[2]
  }));
  download("schedule.csv", toCSV(rows));
};
qs("#exportRaw").onclick = ()=> download("raw_data.csv", toCSV(state.raw));
qs("#exportPit").onclick = ()=> download("pit_scouting.csv", toCSV(state.pit));
qs("#exportJson").onclick = ()=> download("reefscape_scouter.json", JSON.stringify(state, null, 2));
qs("#importFile").onchange = (e)=>{
  const f = e.target.files?.[0]; if(!f) return;
  const fr = new FileReader();
  fr.onload = ()=>{
    try{
      const obj = JSON.parse(fr.result);
      Object.assign(state, obj);
      saveAll(); boot();
    }catch(err){ alert("Invalid JSON"); }
  };
  fr.readAsText(f);
};
qs("#clearStorage").onclick = ()=>{ if(confirm("Clear localStorage & reset?")){ localStorage.removeItem(LS_KEY); location.reload(); } };
qs("#saveCfg").onclick = saveSettings;
qs("#saveWeights").onclick = saveWeights;
qs("#parseSchedule").onclick = ()=>{
  const txt = qs("#schedulePaste").value;
  state.schedule = parseScheduleText(txt);
  onScheduleUpdated();
};
qs("#clearSchedule").onclick = ()=>{
  state.schedule = []; state.scheduleExpanded = []; state.raw = [];
  renderSchedule(); renderSchedExpanded(); renderSchedulePicklist(); renderRaw(); renderPlanner(); saveAll();
};
qs("#recompute").onclick = ()=> recomputeEverything();
qs("#pickMatch").onchange = ()=>{
  const m = asInt(qs("#pickMatch").value);
  if(!m) return;
  const s = state.schedule.find(x=>x.comp?.toLowerCase().startsWith("qm") && asInt(x.match)===m);
  if(!s) return;
  qs("#r1").value=s.red[0]||""; qs("#r2").value=s.red[1]||""; qs("#r3").value=s.red[2]||"";
  qs("#b1").value=s.blue[0]||""; qs("#b2").value=s.blue[1]||""; qs("#b3").value=s.blue[2]||"";
  computePredictions();
};
["#r1","#r2","#r3","#b1","#b2","#b3"].forEach(id=> qs(id).addEventListener("input", computePredictions));

/* Recompute */
function recomputeEverything(){
  state.raw.forEach(computePointsForRow);
  const simple = computeSimpleAverages(); renderTableFromObjects("avgTbl", simple, AVG_HEADERS);
  const weighted = computeWeightedAverages(state.config.decay);
  renderTableFromObjects("wavgTbl", weighted, AVG_HEADERS.map(h=> h==="Avg TOTAL"?"Wgt TOTAL":h.replace("Avg ","Wgt ")));
  renderPlanner();
  computePredictions();
  saveAll();
}

/* Boot */
function boot(){
  loadAll();
  renderRules();
  bindSettings();
  renderSchedExpanded();
  renderSchedule();
  renderSchedulePicklist();
  renderAvgHeaders();
  renderPit();
  renderRawHeadersAndBody();
  recomputeEverything();
}
boot();
</script>
</body>
</html>
