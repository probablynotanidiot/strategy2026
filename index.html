<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FRC REEFSCAPE 2025 Scouting (with TBA + Paper Scan)</title>
<style>
  :root{
    --bg:#0b0f14; --card:#111722; --muted:#98a2b3; --text:#e6edf3; --accent:#2e7dd7; --accent2:#00b894; --warn:#ffd166;
    --border:#1f2a3a;
  }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,"Noto Sans";
       background:var(--bg); color:var(--text); margin:0; padding:24px;}
  h1,h2{margin:12px 0 8px}
  small, .muted{color:var(--muted)}
  .row{display:flex; gap:16px; flex-wrap:wrap}
  .card{background:var(--card); border:1px solid var(--border); border-radius:12px; padding:14px; flex:1 1 420px; min-width:360px}
  table{width:100%; border-collapse:collapse; font-size:13px; border:1px solid var(--border); background:#0f1520}
  thead th{position:sticky; top:0; background:#0e1522; z-index:1}
  th, td{border-bottom:1px solid var(--border); padding:6px 8px; text-align:left; vertical-align:top}
  tbody tr:hover{background:#0b1220}
  input[type="number"], input[type="text"], input[type="password"], select, textarea{
    width:100%; box-sizing:border-box; padding:8px 10px; background:#0d1420; color:var(--text);
    border:1px solid var(--border); border-radius:8px; font-size:14px;
  }
  input[type="checkbox"]{transform:scale(1.2); cursor:pointer}
  textarea{min-height:84px}
  button{background:var(--accent); border:none; color:#fff; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600}
  button.secondary{background:#263445}
  button.ghost{background:transparent; border:1px solid var(--border)}
  .pill{display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid var(--border)}
  .ok{color:#c6f6d5; border-color:#23543f; background:#0f2b1f}
  .warn{color:#fff1c1; border-color:#5d4a1e; background:#2a2316}
  .bad{color:#ffd1d1; border-color:#553232; background:#2a1717}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .scroll{max-height:360px; overflow:auto; border:1px solid var(--border); border-radius:10px}
  .hscroll{overflow-x:auto;}
  .tight th,.tight td{padding:4px 6px}
  .grid{display:grid; gap:8px; grid-template-columns:repeat(4,minmax(0,1fr))}
  .grid-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .grid-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  .footer{margin-top:12px; display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .help{font-size:12px; line-height:1.35}
  .nowrap{white-space:nowrap}

  /* WIDER raw table + big team cell for up to 6 digits */
  #rawTbl{ min-width:1680px; }
  #rawTbl thead th{ white-space:nowrap; }
  #rawTbl input[type="number"], #rawTbl input[type="text"], #rawTbl select { font-size:14px; padding:8px 10px; }
  #rawTbl td:nth-child(4) input { font-weight:700; letter-spacing:0.5px; } /* Team input bolder */
  #rawTbl td:nth-child(4) input, #rawTbl td:nth-child(3) select { min-width:120px; } /* Team + Match bigger */

  #rawTbl thead tr:first-child th{ top:0; z-index:3; }
  #rawTbl thead tr:nth-child(2) th{ top:28px; z-index:2; }

  /* Simple modal for the scanner */
  .modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.6); z-index:999;}
  .modal.open{display:flex;}
  .modal .panel{background:#0e1522; border:1px solid var(--border); border-radius:12px; padding:12px; max-width:900px; width:96%;}
  .scan-area{display:grid; grid-template-columns: 1fr 320px; gap:12px;}
  video{width:100%; max-height:480px; background:#000; border-radius:8px; border:1px solid var(--border);}
  .scan-log{height:480px; overflow:auto; background:#0b1220; border:1px dashed var(--border); border-radius:8px; padding:8px; font-size:12px;}
</style>
<!-- OCR library (client-side) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>

<h1>FRC REEFSCAPE 2025 — Scouting (Tables-only Web App) + TBA Fetch + Paper Scan</h1>
<p class="muted help">Fetch/paste schedule → build your own <b>Raw Data</b> rows from selectors (Comp → Match → Team) → alliance autofills, checkboxes & caps → averages, predictor, planner. Data saves to your browser. Paper scouting: print sheets → scan with camera → auto-ingest.</p>

<div class="row">
  <!-- SETTINGS -->
  <section class="card" style="max-width:600px">
    <h2>Settings</h2>
    <table class="tight">
      <tbody>
        <tr><th style="width:45%">Our Team</th>
          <td><input id="ourTeam" type="number" placeholder="e.g., 1234" /></td></tr>
        <tr><th>Decay Factor (weighted avg)</th>
          <td><input id="decay" type="number" step="0.01" min="0" max="1" value="0.85"/></td></tr>
        <tr><th>Max Matches in Schedule</th>
          <td><input id="maxMatches" type="number" value="200"/></td></tr>
      </tbody>
    </table>

    <h3>Per-Robot Max Caps (enforced per row)</h3>
    <table class="tight">
      <tbody>
        <tr><th>Max Coral L1</th><td><input id="capL1" type="number" value="999"/></td></tr>
        <tr><th>Max Coral L2</th><td><input id="capL2" type="number" value="12"/></td></tr>
        <tr><th>Max Coral L3</th><td><input id="capL3" type="number" value="12"/></td></tr>
        <tr><th>Max Coral L4</th><td><input id="capL4" type="number" value="12"/></td></tr>
        <tr><th>Max Algae (Total Proc+Net)</th><td><input id="capAlgTotal" type="number" value="9"/></td></tr>
      </tbody>
    </table>

    <h3>RP Thresholds</h3>
    <table class="tight">
      <tbody>
        <tr><th>Coral per Level</th><td><input id="rpCoralPerLevel" type="number" value="7"/></td></tr>
        <tr><th>Levels Required (no Coop)</th><td><input id="rpLevels" type="number" value="4"/></td></tr>
        <tr><th>Levels Required (with Coop)</th><td><input id="rpLevelsCoop" type="number" value="3"/></td></tr>
        <tr><th>Barge RP Points</th><td><input id="rpBargePts" type="number" value="16"/></td></tr>
      </tbody>
    </table>

    <div class="footer">
      <button id="saveCfg">Save settings</button>
      <span class="muted">Autosaves too.</span>
    </div>
    <hr/>
    <h3>Import / Export</h3>
    <div class="footer">
      <button id="exportJson">Export JSON</button>
      <label class="ghost pill">
        <input id="importFile" type="file" accept="application/json" style="display:none"/>
        <span class="mono">Import JSON…</span>
      </label>
      <button id="clearStorage" class="secondary">Clear localStorage</button>
    </div>
  </section>

  <!-- RULES + STRATEGY -->
  <section class="card">
    <h2>Rules (REEFSCAPE 2025)</h2>
    <div class="scroll">
      <table id="rulesTbl">
        <thead><tr><th>Item</th><th>Auto</th><th>Tele</th><th>Notes</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
    <h3>Strategy Weights & Reliability Map</h3>
    <table class="tight" id="weightsTbl">
      <tbody>
        <tr><th style="width:45%">Auto Points Weight</th><td><input id="wAuto" type="number" step="0.1" value="1"/></td></tr>
        <tr><th>Teleop Points Weight</th><td><input id="wTele" type="number" step="0.1" value="1"/></td></tr>
        <tr><th>Endgame Points Weight</th><td><input id="wEnd" type="number" step="0.1" value="1"/></td></tr>
        <tr><th>Foul Impact Weight</th><td><input id="wFoul" type="number" step="0.1" value="1"/></td></tr>
        <tr><th>Reliability Floor</th><td><input id="relFloor" type="number" step="0.05" value="0.8"/></td></tr>
        <tr><th>Reliability Ceil</th><td><input id="relCeil" type="number" step="0.05" value="1.2"/></td></tr>
      </tbody>
    </table>
    <div class="footer">
      <button id="saveWeights">Save weights</button>
    </div>
  </section>
</div>

<!-- SCHEDULE -->
<section class="card">
  <h2>Schedule (Fetch from TBA or Copy & Paste)</h2>

  <!-- TBA Fetch Controls -->
  <div class="grid-3">
    <div>
      <label class="muted">Event Key</label>
      <input id="tbaEventKey" placeholder="e.g. 2025nyny" />
    </div>
    <div>
      <label class="muted">Match # (optional filter)</label>
      <input id="tbaMatchFilter" type="number" min="1" placeholder="e.g. 33" />
    </div>
    <div>
      <label class="muted">TBA API Key (stored only in this browser)</label>
      <input id="tbaKey" type="password" placeholder="paste X-TBA-Auth-Key" />
    </div>
  </div>
  <div class="footer">
    <button id="saveTBAKey">Save Key</button>
    <button id="fetchFromTBA">Fetch from TBA</button>
    <button id="importTBAJson" class="ghost">Import TBA JSON…</button>
    <input id="importTBAFile" type="file" accept="application/json" hidden />
    <small class="muted">Endpoint: <span class="mono">/api/v3/event/{event_key}/matches/simple</span></small>
  </div>

  <hr/>

  <p class="help">Or paste rows with headers: <span class="mono">Event | CompLevel | Set | Match | Time | Red1 | Red2 | Red3 | Blue1 | Blue2 | Blue3</span></p>
  <div class="grid-2">
    <textarea id="schedulePaste" placeholder="Paste schedule rows here…"></textarea>
    <div>
      <div class="footer">
        <button id="parseSchedule">Parse Schedule</button>
        <button id="clearSchedule" class="secondary">Clear</button>
        <button id="exportSchedule" class="ghost">Export CSV</button>
      </div>
      <p class="muted help">After parsing or fetching, the app builds <b>Schedule</b> + <b>Schedule Expanded</b>. Raw Data is manual: add rows with the dropdowns.</p>
    </div>
  </div>
  <div class="scroll" style="margin-top:10px">
    <table id="scheduleTbl">
      <thead><tr>
        <th>Event</th><th>CompLvl</th><th>Set</th><th>Match</th><th>Time</th>
        <th>Red1</th><th>Red2</th><th>Red3</th><th>Blue1</th><th>Blue2</th><th>Blue3</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- SCHEDULE EXPANDED (read-only) -->
<section class="card">
  <h2>Schedule Expanded (6 rows per match)</h2>
  <div class="scroll">
    <table id="schedExpTbl">
      <thead><tr>
        <th>Event</th><th>CompLvl</th><th>Set</th><th>Match</th><th>Time</th><th>Alliance</th><th>Team</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- RAW DATA (manual; schedule-driven selectors) -->
<section class="card">
  <h2>Raw Data (Manual; dropdowns fed by Schedule)</h2>
  <p class="help">Add a scouting row. Pick <i>Comp</i> → <i>Match</i> → <i>Team</i>. Alliance & Event auto-fill. Booleans are checkboxes; counts are capped across Auto+Tele. Negatives are blocked.</p>
  <div class="footer">
    <button id="addRawRow">Add Row</button>
    <button id="exportRaw" class="ghost">Export CSV</button>
    <button id="printSheets" class="secondary">Print Paper Sheets</button>
    <button id="scanSheets">Scan Paper Sheet (Camera)</button>
  </div>
  <div class="scroll hscroll">
    <table id="rawTbl">
      <thead><tr id="rawHead"></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- PIT SCOUTING -->
<section class="card">
  <h2>Pit Scouting</h2>
  <p class="help">Reliability (1–5) maps to factor using floor/ceil in Strategy Weights.</p>
  <div class="footer">
    <button id="addPitRow" class="ghost">Add Row</button>
    <button id="exportPit" class="ghost">Export CSV</button>
  </div>
  <div class="scroll">
    <table id="pitTbl">
      <thead><tr>
        <th>Team</th><th>Drivetrain</th><th>Max Coral Level</th><th>Auto Coral (Y/N)</th>
        <th>Cage Capability</th><th>Alg → Processor (Y/N)</th><th>Alg → Net (Y/N)</th>
        <th>Reliability (1–5)</th><th>Notes</th><th>ReliabilityFactor</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- TEAM AVERAGES -->
<section class="card">
  <h2>Team Averages (Simple)</h2>
  <div class="footer">
    <button id="recompute">Recompute</button>
  </div>
  <div class="scroll">
    <table id="avgTbl">
      <thead><tr id="avgHead"></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- WEIGHTED AVERAGES -->
<section class="card">
  <h2>Weighted Averages (Recent-weighted)</h2>
  <div class="scroll">
    <table id="wavgTbl">
      <thead><tr id="wavgHead"></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- MATCH PREDICTOR / DASHBOARD -->
<section class="card">
  <h2>Match Predictor & RP Checks</h2>
  <div class="grid-3">
    <table class="tight">
      <tbody>
        <tr><th>Pick schedule match #</th>
          <td>
            <select id="pickMatch"><option value="">—</option></select>
          </td></tr>
        <tr><th>or enter teams (Red)</th>
          <td class="grid-3"><input id="r1" type="number" placeholder="Red1"/><input id="r2" type="number" placeholder="Red2"/><input id="r3" type="number" placeholder="Red3"/></td></tr>
        <tr><th>enter teams (Blue)</th>
          <td class="grid-3"><input id="b1" type="number" placeholder="Blue1"/><input id="b2" type="number" placeholder="Blue2"/><input id="b3" type="number" placeholder="Blue3"/></td></tr>
      </tbody>
    </table>
    <table>
      <thead><tr><th>Totals</th><th>Red</th><th>Blue</th></tr></thead>
      <tbody>
        <tr><td>Simple</td><td id="predRedSimple">—</td><td id="predBlueSimple">—</td></tr>
        <tr><td>Weighted</td><td id="predRedWeighted">—</td><td id="predBlueWeighted">—</td></tr>
        <tr><td>Custom + Reliability</td><td id="predRedCustom">—</td><td id="predBlueCustom">—</td></tr>
      </tbody>
    </table>
    <table>
      <thead><tr><th>RP Checks (approx)</th><th>Red</th></tr></thead>
      <tbody>
        <tr><td>AUTO RP?</td><td id="rpAuto">—</td></tr>
        <tr><td>CORAL RP?</td><td id="rpCoral">—</td></tr>
        <tr><td>BARGE RP?</td><td id="rpBarge">—</td></tr>
        <tr><td>Coop Bonus likely?</td><td id="rpCoop">—</td></tr>
      </tbody>
    </table>
  </div>
</section>

<!-- SCOUT PLANNER -->
<section class="card">
  <h2>Scout Planner</h2>
  <div class="row">
    <div class="card" style="min-width:360px">
      <h3>Our Matches</h3>
      <div class="scroll">
        <table id="ourMatchesTbl">
          <thead><tr><th>Match</th><th>Alliance</th><th>Partners</th><th>Opponents</th><th>Time</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
    <div class="card" style="min-width:360px">
      <h3>Priority Teams to Scout</h3>
      <div class="scroll">
        <table id="priorityTbl">
          <thead><tr><th>Team</th><th>First Shared Match</th><th>Role vs Us</th><th>Scouted Rows</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <h3>Opponents by Match (coverage gaps)</h3>
      <div class="scroll">
        <table id="oppChecklistTbl">
          <thead><tr><th>Match</th><th>Opp1</th><th>Opp2</th><th>Opp3</th><th>Gaps</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
    <div class="card" style="min-width:360px">
      <h3>Other Matches to Scout</h3>
      <p class="muted help">Matches that don’t include us but do include teams we face. Highlighted teams are the opponents we face. Sorted by QM → SF → F.</p>
      <div class="scroll">
        <table id="otherMatchesTbl">
          <thead>
            <tr>
              <th>Match</th>
              <th>Teams (highlighted = opponents we face)</th>
              <th>Important Teams</th>
              <th>Count</th>
              <th>Time</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>
</section>

<!-- Scanner Modal -->
<div id="scanModal" class="modal">
  <div class="panel">
    <div class="footer" style="justify-content:space-between">
      <h3 style="margin:0">Scan Paper Sheet</h3>
      <div>
        <button id="closeScan" class="ghost">Close</button>
        <button id="captureFrame">Capture & OCR</button>
      </div>
    </div>
    <div class="scan-area" style="margin-top:8px">
      <video id="scanVideo" autoplay playsinline muted></video>
      <div>
        <div class="scan-log" id="scanLog"></div>
      </div>
    </div>
    <small class="muted">Tips: good lighting · fill with block letters · keep sheet flat in frame.</small>
  </div>
</div>

<script>
/* =========================
   Data model & persistence
   ========================= */
const state = {
  config: {
    ourTeam: "",
    decay: 0.85,
    maxMatches: 200,
    /* NEW caps as you requested:
       - L1 virtually unlimited (use 999 default)
       - L2/L3/L4 up to 12 each (Auto+Tele combined)
       - Algae TOTAL (Proc+Net across Auto+Tele) up to 9
    */
    caps: { L1:999, L2:12, L3:12, L4:12, AlgTotal:9 },
    rp: { coralPerLevel:7, levels:4, levelsCoop:3, bargePts:16 }
  },
  weights: { wAuto:1, wTele:1, wEnd:1, wFoul:1, relFloor:0.8, relCeil:1.2 },
  rules: [
    { item:"LEAVE", auto:3, tele:0, notes:"AUTO mobility" },
    { item:"CORAL L1 (trough)", auto:3, tele:2, notes:"" },
    { item:"CORAL L2", auto:4, tele:3, notes:"" },
    { item:"CORAL L3", auto:6, tele:4, notes:"" },
    { item:"CORAL L4", auto:7, tele:5, notes:"" },
    { item:"ALGAE in PROCESSOR", auto:6, tele:6, notes:"same value" },
    { item:"ALGAE in NET", auto:4, tele:4, notes:"same value" },
    { item:"PARK", auto:0, tele:2, notes:"endgame" },
    { item:"CAGE SHALLOW", auto:0, tele:6, notes:"endgame" },
    { item:"CAGE DEEP", auto:0, tele:12, notes:"endgame" },
    { item:"MINOR FOUL (opp +2)", auto:0, tele:2, notes:"opponent gets points" },
    { item:"MAJOR FOUL (opp +6)", auto:0, tele:6, notes:"opponent gets points" },
  ],
  schedule: [],           // [{event,comp,set,match,time,red:[...],blue:[...]}]
  scheduleExpanded: [],   // [{event,comp,set,match,time,alliance,team}]
  raw: [],                // manual rows now
  pit: [],
  tba: { key: "", lastEventKey: "" }
};

// localStorage
const LS_KEY = "reefscape2025_scout";
function saveAll(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
function loadAll(){
  const s = localStorage.getItem(LS_KEY); if (!s) return;
  try { Object.assign(state, JSON.parse(s)); } catch(e){}
}

/* Utils */
const qs = sel => document.querySelector(sel);
function csvEscape(v){ if(v==null) return ""; v = String(v); return /[,"\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v; }
function toCSV(rows){
  if(!rows.length) return "";
  const keys = Object.keys(rows[0]);
  return [keys.join(","), ...rows.map(r=>keys.map(k=>csvEscape(r[k])).join(","))].join("\n");
}
function download(filename, text){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([text], {type:"text/plain"}));
  a.download = filename; a.click(); URL.revokeObjectURL(a.href);
}
function uniq(arr){ return [...new Set(arr)]; }
function sum(arr){ return arr.reduce((a,b)=>a+(+b||0),0); }
function avg(arr){ const v=arr.filter(x=>x!=="" && x!=null); return v.length? sum(v)/v.length : 0; }
function asInt(v){ const n = parseInt(v,10); return isFinite(n)? n : 0; }
function asNum(v){ const n = Number(v); return isFinite(n)? n : 0; }
function mkRow(cols){ const tr=document.createElement("tr"); cols.forEach(c=>{ const td=document.createElement("td"); if(c instanceof Node){ td.appendChild(c);} else {td.innerHTML=c;} tr.appendChild(td); }); return tr; }

/* Render rules & settings */
function renderRules(){
  const tb = qs("#rulesTbl tbody"); tb.innerHTML="";
  state.rules.forEach(r=> tb.appendChild(mkRow([r.item, r.auto, r.tele, r.notes])));
}
function bindSettings(){
  qs("#ourTeam").value = state.config.ourTeam || "";
  qs("#decay").value = state.config.decay;
  qs("#maxMatches").value = state.config.maxMatches;

  qs("#capL1").value = state.config.caps.L1;
  qs("#capL2").value = state.config.caps.L2;
  qs("#capL3").value = state.config.caps.L3;
  qs("#capL4").value = state.config.caps.L4;
  qs("#capAlgTotal").value = state.config.caps.AlgTotal;

  qs("#rpCoralPerLevel").value = state.config.rp.coralPerLevel;
  qs("#rpLevels").value = state.config.rp.levels;
  qs("#rpLevelsCoop").value = state.config.rp.levelsCoop;
  qs("#rpBargePts").value = state.config.rp.bargePts;

  qs("#wAuto").value = state.weights.wAuto;
  qs("#wTele").value = state.weights.wTele;
  qs("#wEnd").value = state.weights.wEnd;
  qs("#wFoul").value = state.weights.wFoul;
  qs("#relFloor").value = state.weights.relFloor;
  qs("#relCeil").value = state.weights.relCeil;

  qs("#tbaKey").value = state.tba.key || "";
  qs("#tbaEventKey").value = state.tba.lastEventKey || "";
}
function saveSettings(){
  state.config.ourTeam = qs("#ourTeam").value.trim();
  state.config.decay = asNum(qs("#decay").value);
  state.config.maxMatches = asInt(qs("#maxMatches").value);

  state.config.caps.L1 = Math.max(0, asInt(qs("#capL1").value));
  state.config.caps.L2 = Math.max(0, asInt(qs("#capL2").value));
  state.config.caps.L3 = Math.max(0, asInt(qs("#capL3").value));
  state.config.caps.L4 = Math.max(0, asInt(qs("#capL4").value));
  state.config.caps.AlgTotal = Math.max(0, asInt(qs("#capAlgTotal").value));

  state.config.rp.coralPerLevel = Math.max(0, asInt(qs("#rpCoralPerLevel").value));
  state.config.rp.levels = Math.max(0, asInt(qs("#rpLevels").value));
  state.config.rp.levelsCoop = Math.max(0, asInt(qs("#rpLevelsCoop").value));
  state.config.rp.bargePts = Math.max(0, asInt(qs("#rpBargePts").value));
  saveAll(); recomputeEverything();
}
function saveWeights(){
  state.weights.wAuto = asNum(qs("#wAuto").value);
  state.weights.wTele = asNum(qs("#wTele").value);
  state.weights.wEnd  = asNum(qs("#wEnd").value);
  state.weights.wFoul = asNum(qs("#wFoul").value);
  state.weights.relFloor = asNum(qs("#relFloor").value);
  state.weights.relCeil  = asNum(qs("#relCeil").value);
  saveAll(); recomputeEverything();
}

/* TBA Fetch + Import JSON (unchanged core) */
function normalizeFromTBA(json, eventKey){
  return json.map(m => ({
    event: eventKey || (m.event_key||""),
    comp: m.comp_level || "",
    set: m.set_number || 1,
    match: m.match_number || 0,
    time: m.time || m.predicted_time || m.actual_time || "",
    red:[(m.alliances?.red?.team_keys?.[0]||"").replace("frc",""),
         (m.alliances?.red?.team_keys?.[1]||"").replace("frc",""),
         (m.alliances?.red?.team_keys?.[2]||"").replace("frc","")].map(asInt),
    blue:[(m.alliances?.blue?.team_keys?.[0]||"").replace("frc",""),
          (m.alliances?.blue?.team_keys?.[1]||"").replace("frc",""),
          (m.alliances?.blue?.team_keys?.[2]||"").replace("frc","")].map(asInt)
  })).sort((a,b)=> (a.comp||"").localeCompare(b.comp||"") || a.match-b.match)
    .slice(0, state.config.maxMatches);
}
async function fetchFromTBA(){
  const key = (qs("#tbaKey").value || state.tba.key || "").trim();
  const eventKey = (qs("#tbaEventKey").value || "").trim();
  const matchFilter = asInt(qs("#tbaMatchFilter").value);
  if(!key){ alert("Enter your TBA API key."); return; }
  if(!eventKey){ alert("Enter an event key (e.g., 2025nyny)."); return; }
  try{
    const url = `https://www.thebluealliance.com/api/v3/event/${encodeURIComponent(eventKey)}/matches/simple`;
    const res = await fetch(url, { headers: { "X-TBA-Auth-Key": key }});
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    let data = await res.json();
    if(matchFilter>0) data = data.filter(m => asInt(m.match_number)===matchFilter);
    state.schedule = normalizeFromTBA(data, eventKey);
    state.tba.lastEventKey = eventKey;
    onScheduleUpdated();
  }catch(err){ alert("Fetch failed: " + err.message); }
}
qs("#saveTBAKey").onclick = ()=>{ state.tba.key = qs("#tbaKey").value.trim(); saveAll(); alert("Saved TBA key to this browser."); };
qs("#fetchFromTBA").onclick = fetchFromTBA;
qs("#importTBAJson").onclick = ()=> qs("#importTBAFile").click();
qs("#importTBAFile").onchange = async (e)=>{
  const f = e.target.files?.[0]; if(!f) return;
  try{
    const json = JSON.parse(await f.text());
    const eventKey = qs("#tbaEventKey").value.trim();
    const matchFilter = asInt(qs("#tbaMatchFilter").value);
    let data = Array.isArray(json)? json : [];
    if(matchFilter>0) data = data.filter(m => asInt(m.match_number)===matchFilter);
    state.schedule = normalizeFromTBA(data, eventKey);
    onScheduleUpdated();
  }catch{ alert("Invalid JSON."); }
};

/* Schedule parse/paste */
function parseScheduleText(txt){
  const rows = txt.trim().split(/\r?\n/).filter(Boolean);
  const out = [];
  for (const line of rows){
    // CSV-aware split fallback to TSV/whitespace
    let parts = line.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/).map(s=>s.replace(/^"(.*)"$/,'$1').trim());
    if (parts.length < 11){ parts = line.split(/\t|\s{2,}/).map(s=>s.trim()); }
    if (parts.length < 11) continue;
    const [event,comp,set,match,time, r1,r2,r3, b1,b2,b3] = parts;
    out.push({
      event, comp, set:asInt(set), match:asInt(match), time,
      red:[r1,r2,r3].map(asInt), blue:[b1,b2,b3].map(asInt)
    });
  }
  out.sort((a,b)=> (a.comp||"").localeCompare(b.comp||"") || a.match-b.match);
  return out.slice(0, state.config.maxMatches);
}
function renderSchedule(){
  const tb = qs("#scheduleTbl tbody"); tb.innerHTML="";
  const matchSelect = qs("#pickMatch"); matchSelect.innerHTML = `<option value="">—</option>`;
  state.schedule.forEach(m=>{
    tb.appendChild(mkRow([m.event,m.comp,m.set,m.match,m.time, ...m.red, ...m.blue]));
    if (m.comp && m.comp.toLowerCase().startsWith("qm")){
      const opt = document.createElement("option");
      opt.value=String(m.match); opt.textContent = m.match;
      matchSelect.appendChild(opt);
    }
  });
}
function expandSchedule(){
  const rows = [];
  for (const m of state.schedule){
    const base = {event:m.event, comp:m.comp, set:m.set, match:m.match, time:m.time};
    for (let i=0;i<3;i++) rows.push({...base, alliance:"Red", team: m.red[i]||""});
    for (let i=0;i<3;i++) rows.push({...base, alliance:"Blue", team: m.blue[i]||""});
  }
  state.scheduleExpanded = rows;
}
function renderSchedExpanded(){
  const tb = qs("#schedExpTbl tbody"); tb.innerHTML="";
  state.scheduleExpanded.forEach(r=> tb.appendChild(mkRow([r.event,r.comp,r.set,r.match,r.time,r.alliance,r.team])));
}
function onScheduleUpdated(){
  expandSchedule();
  renderSchedule();
  renderSchedExpanded();
  renderSchedulePicklist();
  renderPlanner();
  renderRaw();            // refresh dropdown options
  recomputeEverything();
  saveAll();
}

/* ======== RAW DATA (manual rows; selectors driven by schedule) ======== */
const RAW_HEADERS = [
  "Event","Comp","Match","Team","Alliance",
  "AUTO Leave",
  "AUTO: L1","AUTO: L2","AUTO: L3","AUTO: L4",
  "AUTO: Alg→Proc","AUTO: Alg→Net",
  "TELE: L1","TELE: L2","TELE: L3","TELE: L4",
  "TELE: Alg→Proc","TELE: Alg→Net",
  "END: Park","END: Shallow","END: Deep",
  "Fouls: Minor","Fouls: Major",
  "Notes",
  "AUTO Pts","TELE Pts","END Pts","TOTAL","Opp Pts From Fouls"
];

function renderRawHeaders(){
  const thead = document.querySelector("#rawTbl thead");
  thead.innerHTML = "";

  const cat = document.createElement("tr");
  [
    ["",5],
    ["AUTO",7],
    ["TELEOP",6],
    ["ENDGAME",3],
    ["FOULS",2],
    ["NOTES",1],
    ["POINTS",5]
  ].forEach(([label,span])=>{
    const th=document.createElement("th");
    th.textContent = label;
    th.colSpan = span;
    cat.appendChild(th);
  });
  thead.appendChild(cat);

  const detail = document.createElement("tr");
  const cols = [
    "Event","Comp","Match","Team","Alliance",
    "Leave (Auto)","L1 Auto","L2 Auto","L3 Auto","L4 Auto","Alg→Proc Auto","Alg→Net Auto",
    "L1 Tele","L2 Tele","L3 Tele","L4 Tele","Alg→Proc Tele","Alg→Net Tele",
    "Park","Shallow","Deep",
    "Minor","Major",
    "Notes",
    "Auto Pts","Tele Pts","End Pts","Total","Opp Pts (Fouls)"
  ];
  cols.forEach(h=>{ const th=document.createElement("th"); th.textContent=h; detail.appendChild(th); });
  thead.appendChild(detail);
}

function ensureNoNegative(row, key){
  // Force non-negative for every numeric field.
  if (typeof row[key] === "number" && row[key] < 0) row[key] = 0;
  if (typeof row[key] === "string" && row[key].trim() !== ""){
    const n = asNum(row[key]);
    if (isFinite(n) && n < 0) row[key] = 0;
  }
}

// NEW: clamp for total Algae and level caps for L2~L4; L1 unlimited
function clampAllCaps(row, changedKey){
  const C = state.config.caps;

  // Per-level combined (Auto+Tele)
  const levels = ["L1","L2","L3","L4"];
  for (const L of levels){
    const aK = `AUTO: ${L}`;
    const tK = `TELE: ${L}`;
    row[aK] = Math.max(0, asInt(row[aK]||0));
    row[tK] = Math.max(0, asInt(row[tK]||0));
    if (L === "L1"){
      // L1 unlimited (but keep it sane if someone sets very high caps)
      continue;
    }
    const sumLT = asInt(row[aK]) + asInt(row[tK]);
    const cap = C[L];
    if (sumLT > cap){
      // Prefer to clamp the just-changed key; leave the other as-is when possible
      if (changedKey === aK){
        row[aK] = Math.max(0, cap - asInt(row[tK]));
      }else if (changedKey === tK){
        row[tK] = Math.max(0, cap - asInt(row[aK]));
      }else{
        // Split proportionally as fallback
        const ratio = sumLT ? cap/sumLT : 0;
        row[aK] = Math.floor(asInt(row[aK])*ratio);
        row[tK] = Math.max(0, cap - row[aK]);
      }
    }
  }

  // ALGAE total across Proc+Net and Auto+Tele
  const keysAlg = ["AUTO: Alg→Proc","TELE: Alg→Proc","AUTO: Alg→Net","TELE: Alg→Net"];
  keysAlg.forEach(k => row[k] = Math.max(0, asInt(row[k]||0)));
  let algTotal = keysAlg.reduce((a,k)=>a + asInt(row[k]), 0);
  const capAlg = C.AlgTotal;
  if (algTotal > capAlg){
    // Reduce the field the user just changed first, then others if needed
    const order = [changedKey, ...keysAlg.filter(k=>k!==changedKey)];
    for (const k of order){
      if (!keysAlg.includes(k)) continue;
      if (algTotal <= capAlg) break;
      const overshoot = algTotal - capAlg;
      const cur = asInt(row[k]);
      if (cur <= 0) continue;
      const newVal = Math.max(0, cur - overshoot);
      row[k] = newVal;
      algTotal = keysAlg.reduce((a,kk)=>a + asInt(row[kk]), 0);
    }
  }
}

// Endgame exclusivity
function exclusiveEndgame(row, picked){
  if (picked==="END: Park"){ row["END: Shallow"]=0; row["END: Deep"]=0; }
  if (picked==="END: Shallow"){ row["END: Park"]=0; row["END: Deep"]=0; }
  if (picked==="END: Deep"){ row["END: Park"]=0; row["END: Shallow"]=0; }
}

// Points rules
const RULE = {
  LEAVE: {auto:3, tele:0},
  L1: {auto:3, tele:2},
  L2: {auto:4, tele:3},
  L3: {auto:6, tele:4},
  L4: {auto:7, tele:5},
  ALG_PROC: {auto:6, tele:6},
  ALG_NET: {auto:4, tele:4},
  PARK: {auto:0, tele:2},
  CAGE_SH: {auto:0, tele:6},
  CAGE_DP: {auto:0, tele:12}
};
function computePointsForRow(r){
  const n = k => asNum(r[k]||0);
  const auto = (r["AUTO Leave"]?1:0)*RULE.LEAVE.auto
             + n("AUTO: L1")*RULE.L1.auto + n("AUTO: L2")*RULE.L2.auto + n("AUTO: L3")*RULE.L3.auto + n("AUTO: L4")*RULE.L4.auto
             + n("AUTO: Alg→Proc")*RULE.ALG_PROC.auto + n("AUTO: Alg→Net")*RULE.ALG_NET.auto;
  const tele = n("TELE: L1")*RULE.L1.tele + n("TELE: L2")*RULE.L2.tele + n("TELE: L3")*RULE.L3.tele + n("TELE: L4")*RULE.L4.tele
             + n("TELE: Alg→Proc")*RULE.ALG_PROC.tele + n("TELE: Alg→Net")*RULE.ALG_NET.tele;
  const endp = (r["END: Park"]?1:0)*RULE.PARK.tele
             + (r["END: Shallow"]?1:0)*RULE.CAGE_SH.tele
             + (r["END: Deep"]?1:0)*RULE.CAGE_DP.tele;
  r["AUTO Pts"]=auto; r["TELE Pts"]=tele; r["END Pts"]=endp;
  r["TOTAL"]=auto+tele+endp;
  r["Opp Pts From Fouls"] = 2*n("Fouls: Minor") + 6*n("Fouls: Major");
}

// Inputs (with min=0)
function inputText(value, on){ const i=document.createElement("input"); i.value=value??""; i.onchange=e=>on(e.target.value); return i; }
function inputNum(value, on){
  const i=document.createElement("input");
  i.type="number"; i.step="1"; i.min="0";
  i.value=(value==null||value==="")?"":Number(value);
  i.onchange=e=>on(e.target.value);
  i.oninput=e=>{ if (e.target.value === "") return; if (Number(e.target.value) < 0) e.target.value = 0; };
  return i;
}
function inputCheckbox(checked, on){
  const i=document.createElement("input"); i.type="checkbox"; i.checked=!!checked;
  i.onchange=e=> on(e.target.checked?1:0); return i;
}
function selectElem(options, val, onChange, placeholder="—", disabled=false){
  const s=document.createElement("select");
  if (placeholder!=null){ const o=document.createElement("option"); o.value=""; o.textContent=placeholder; s.appendChild(o); }
  options.forEach(v=>{ const o=document.createElement("option"); o.value=String(v); o.textContent=String(v); s.appendChild(o); });
  s.value = val||""; s.disabled = disabled; s.onchange = e=> onChange(e.target.value);
  return s;
}

// Helpers to feed dropdowns
function getCompLevels(){
  return uniq(state.schedule.map(s => (s.comp||"").toString())).sort((a,b)=>a.localeCompare(b));
}
function getMatchesForComp(comp){
  return uniq(state.schedule.filter(s => s.comp===comp).map(s => asInt(s.match))).sort((a,b)=>a-b);
}
function getSchedFor(comp, match){
  return state.schedule.find(s => s.comp===comp && asInt(s.match)===asInt(match));
}
function getTeamsFor(comp, match){
  const s = getSchedFor(comp, match);
  if (!s) return {red:[], blue:[], all:[]};
  const red = s.red.map(asInt), blue = s.blue.map(asInt);
  return { red, blue, all:[...red, ...blue] };
}

// Create a blank manual row
function newManualRawRow(){
  const r = {};
  RAW_HEADERS.forEach(h=>{
    if (["AUTO Leave","END: Park","END: Shallow","END: Deep"].includes(h)) r[h]=0;
    else r[h]="";
  });
  r.Event=""; r.Comp=""; r.Match=""; r.Team=""; r.Alliance="";
  r["Fouls: Minor"]=0; r["Fouls: Major"]=0;
  r["AUTO: L1"]=0; r["AUTO: L2"]=0; r["AUTO: L3"]=0; r["AUTO: L4"]=0;
  r["AUTO: Alg→Proc"]=0; r["AUTO: Alg→Net"]=0;
  r["TELE: L1"]=0; r["TELE: L2"]=0; r["TELE: L3"]=0; r["TELE: L4"]=0;
  r["TELE: Alg→Proc"]=0; r["TELE: Alg→Net"]=0;
  r["AUTO Pts"]=0; r["TELE Pts"]=0; r["END Pts"]=0; r["TOTAL"]=0; r["Opp Pts From Fouls"]=0;
  return r;
}

// Render Raw table (manual rows)
function renderRawHeadersAndBody(){
  renderRawHeaders();
  renderRaw();
}
function renderRaw(){
  const tb = qs("#rawTbl tbody"); tb.innerHTML="";

  const compLevels = getCompLevels();

  state.raw.forEach((row)=>{
    const cells=[];

    // EVENT (read-only, derived once comp+match chosen)
    const deriveSched = getSchedFor(row.Comp, row.Match);
    const eventText = deriveSched?.event || "";
    row.Event = eventText;

    // COMP select
    const compSel = selectElem(compLevels, row.Comp, (v)=>{
      row.Comp = v || "";
      row.Match = ""; row.Team = ""; row.Alliance="";
      computePointsForRow(row); saveAll(); renderRaw();
    }, "comp", compLevels.length===0);
    cells.push(compSel);

    // MATCH select (depends on comp)
    const matchOpts = row.Comp ? getMatchesForComp(row.Comp) : [];
    const matchSel = selectElem(matchOpts, row.Match, (v)=>{
      row.Match = v || "";
      row.Team=""; row.Alliance="";
      const s = getSchedFor(row.Comp, row.Match);
      row.Event = s?.event || "";
      computePointsForRow(row); saveAll(); renderRaw();
    }, "match", !row.Comp);
    // Event text as first visible cell
    cells.unshift(`<span class="mono">${eventText}</span>`);
    cells.push(matchSel);

    // TEAM select (6 teams of the match)
    const teamsFor = (row.Comp && row.Match)? getTeamsFor(row.Comp, row.Match) : {all:[],red:[],blue:[]};
    const teamSel = selectElem(teamsFor.all, row.Team, (v)=>{
      row.Team = v || "";
      // Auto-alliance
      const tNum = asInt(row.Team);
      if (teamsFor.red.includes(tNum)) row.Alliance="Red";
      else if (teamsFor.blue.includes(tNum)) row.Alliance="Blue";
      else row.Alliance="";
      computePointsForRow(row); saveAll(); renderRaw();
    }, "team", !(row.Comp && row.Match));
    cells.push(teamSel);

    // ALLIANCE (auto)
    cells.push(`<span class="mono">${row.Alliance||""}</span>`);

    // Booleans as checkboxes
    cells.push(inputCheckbox(row["AUTO Leave"], v=>{ row["AUTO Leave"]=v; computePointsForRow(row); saveAll(); renderRaw(); }));

    // Counted fields with clamping & no-negatives
    const cappedNum = (key)=> inputNum(row[key], v=>{
      row[key]=asInt(v); ensureNoNegative(row, key);
      clampAllCaps(row, key);
      computePointsForRow(row); saveAll(); renderRaw();
    });

    ["AUTO: L1","AUTO: L2","AUTO: L3","AUTO: L4",
     "AUTO: Alg→Proc","AUTO: Alg→Net",
     "TELE: L1","TELE: L2","TELE: L3","TELE: L4",
     "TELE: Alg→Proc","TELE: Alg→Net"].forEach(k=> cells.push(cappedNum(k)));

    // Endgame (mutually exclusive) as checkboxes
    const endBox = (k)=> inputCheckbox(row[k], v=>{
      row[k]=v; if(v) exclusiveEndgame(row,k); computePointsForRow(row); saveAll(); renderRaw();
    });
    cells.push(endBox("END: Park"));
    cells.push(endBox("END: Shallow"));
    cells.push(endBox("END: Deep"));

    // Fouls numeric (no negatives)
    cells.push(inputNum(row["Fouls: Minor"], v=>{ row["Fouls: Minor"]=asInt(v); ensureNoNegative(row,"Fouls: Minor"); computePointsForRow(row); saveAll(); renderRaw(); }));
    cells.push(inputNum(row["Fouls: Major"], v=>{ row["Fouls: Major"]=asInt(v); ensureNoNegative(row,"Fouls: Major"); computePointsForRow(row); saveAll(); renderRaw(); }));

    // Notes
    cells.push(inputText(row["Notes"]||"", v=>{ row["Notes"]=v; saveAll(); }));

    // Computed points (read-only)
    ["AUTO Pts","TELE Pts","END Pts","TOTAL","Opp Pts From Fouls"].forEach(h=>{
      cells.push(`<span class="mono">${Number(row[h]||0).toFixed(0)}</span>`);
    });

    tb.appendChild(mkRow(cells));
  });
}
qs("#addRawRow").onclick = ()=>{ state.raw.push(newManualRawRow()); renderRaw(); saveAll(); };

/* Pit scouting */
function reliabilityFactor(team){
  const t = asInt(team);
  const row = state.pit.find(x=>asInt(x.Team)===t);
  if (!row) return 1;
  const rel = asInt(row.Reliability||0);
  const f = state.weights.relFloor, c = state.weights.relCeil;
  if (!rel) return 1;
  return f + (rel-1)*(c-f)/4;
}
function renderPit(){
  const tb = qs("#pitTbl tbody"); tb.innerHTML="";
  const optsDT = ["","Swerve","Tank","West Coast","Mecanum","Other"];
  const optsLvl = ["","L1","L2","L3","L4"];
  const optsYN = ["","Y","N"];
  const optsCage = ["","None","Park","Shallow","Deep"];
  state.pit.forEach((r)=>{
    const mkSel = (arr,val,onchange)=>{ const s=document.createElement("select"); arr.forEach(x=>{const o=document.createElement("option");o.value=x;o.textContent=x;s.appendChild(o);}); s.value=val||""; s.onchange=onchange; return s; };
    const mkInp = (val,on)=>{ const i=document.createElement("input"); i.value=val||""; i.onchange=on; return i; };
    const mkNum = (val,on)=>{ const i=document.createElement("input"); i.type="number"; i.min="1"; i.max="5"; i.step="1"; i.value=val||""; i.onchange=on; return i; };

    const rel = reliabilityFactor(r.Team);
    const tr = mkRow([
      mkInp(r.Team, e=>{r.Team=asInt(e.target.value); saveAll();}),
      mkSel(optsDT, r.Drivetrain, e=>{r.Drivetrain=e.target.value; saveAll();}),
      mkSel(optsLvl, r.MaxCoralLevel, e=>{r.MaxCoralLevel=e.target.value; saveAll();}),
      mkSel(optsYN, r.AutoCoral, e=>{r.AutoCoral=e.target.value; saveAll();}),
      mkSel(optsCage, r.CageCap, e=>{r.CageCap=e.target.value; saveAll();}),
      mkSel(optsYN, r.AlgProc, e=>{r.AlgProc=e.target.value; saveAll();}),
      mkSel(optsYN, r.AlgNet, e=>{r.AlgNet=e.target.value; saveAll();}),
      mkNum(r.Reliability, e=>{r.Reliability=asInt(e.target.value); saveAll(); renderPit();}),
      mkInp(r.Notes, e=>{r.Notes=e.target.value; saveAll();}),
      `<span class="pill ${rel>=1?'ok':'warn'} mono">${rel.toFixed(2)}</span>`
    ]);
    tb.appendChild(tr);
  });
}
qs("#addPitRow").onclick = ()=>{ state.pit.push({Team:""}); renderPit(); saveAll(); };

/* Averages */
const AVG_HEADERS = [
  "Team","Matches",
  "AUTO Leave","AUTO L1","AUTO L2","AUTO L3","AUTO L4",
  "AUTO AlgProc","AUTO AlgNet",
  "TELE L1","TELE L2","TELE L3","TELE L4",
  "TELE AlgProc","TELE AlgNet",
  "END Park","END Shallow","END Deep",
  "Avg AUTO","Avg TELE","Avg END","Avg TOTAL","Avg FOUL to Opp"
];
function renderAvgHeaders(){
  const tr = qs("#avgHead"); tr.innerHTML="";
  AVG_HEADERS.forEach(h=>{const th=document.createElement("th"); th.textContent=h; tr.appendChild(th);});
  const trW = qs("#wavgHead"); trW.innerHTML="";
  AVG_HEADERS.forEach(h=>{const th=document.createElement("th"); th.textContent=(h==="Avg TOTAL"?"Wgt TOTAL":h.replace("Avg ","Wgt ")); trW.appendChild(th);});
}
function groupRowsByTeam(){
  const map = new Map();
  for (const r of state.raw){
    const t = String(r.Team||"").trim(); if (!t) continue;
    if (!map.has(t)) map.set(t, []);
    map.get(t).push(r);
  }
  return map;
}
function computeSimpleAverages(){
  const map = groupRowsByTeam();
  const rows = [];
  for (const [team, arr] of map.entries()){
    const getA = k => avg(arr.map(r=>asNum(r[k])));
    const matches = arr.length;
    rows.push({
      Team:team, Matches:matches,
      "AUTO Leave":getA("AUTO Leave"),
      "AUTO L1":getA("AUTO: L1"),"AUTO L2":getA("AUTO: L2"),"AUTO L3":getA("AUTO: L3"),"AUTO L4":getA("AUTO: L4"),
      "AUTO AlgProc":getA("AUTO: Alg→Proc"), "AUTO AlgNet":getA("AUTO: Alg→Net"),
      "TELE L1":getA("TELE: L1"),"TELE L2":getA("TELE: L2"),"TELE L3":getA("TELE: L3"),"TELE L4":getA("TELE: L4"),
      "TELE AlgProc":getA("TELE: Alg→Proc"), "TELE AlgNet":getA("TELE: Alg→Net"),
      "END Park":getA("END: Park"), "END Shallow":getA("END: Shallow"), "END Deep":getA("END: Deep"),
      "Avg AUTO":avg(arr.map(r=>r["AUTO Pts"])), "Avg TELE":avg(arr.map(r=>r["TELE Pts"])), "Avg END":avg(arr.map(r=>r["END Pts"])),
      "Avg TOTAL":avg(arr.map(r=>r["TOTAL"])), "Avg FOUL to Opp":avg(arr.map(r=>r["Opp Pts From Fouls"]))
    });
  }
  rows.sort((a,b)=>asInt(a.Team)-asInt(b.Team));
  return rows;
}
function latestMatchPerTeam(arr){ return arr.reduce((m,r)=>Math.max(m, asInt(r.Match)||0), 0); }
function computeWeightedAverages(decay){
  const map = groupRowsByTeam();
  const rows = [];
  for (const [team, arr] of map.entries()){
    const latest = latestMatchPerTeam(arr);
    const w = r => Math.pow(decay, Math.max(0, latest - (asInt(r.Match)||0)));
    const wavg = key => {
      let num=0,den=0;
      for (const r of arr){ const val=asNum(r[key]); const wt=w(r); if(isFinite(val)){ num+=val*wt; den+=wt; } }
      return den? num/den : 0;
    };
    rows.push({
      Team:team, Matches:arr.length,
      "AUTO Leave":wavg("AUTO Leave"),
      "AUTO L1":wavg("AUTO: L1"),"AUTO L2":wavg("AUTO: L2"),"AUTO L3":wavg("AUTO: L3"),"AUTO L4":wavg("AUTO: L4"),
      "AUTO AlgProc":wavg("AUTO: Alg→Proc"), "AUTO AlgNet":wavg("AUTO: Alg→Net"),
      "TELE L1":wavg("TELE: L1"),"TELE L2":wavg("TELE: L2"),"TELE L3":wavg("TELE: L3"),"TELE L4":wavg("TELE: L4"),
      "TELE AlgProc":wavg("TELE: Alg→Proc"), "TELE AlgNet":wavg("TELE: Alg→Net"),
      "END Park":wavg("END: Park"), "END Shallow":wavg("END: Shallow"), "END Deep":wavg("END: Deep"),
      "Avg AUTO":wavg("AUTO Pts"), "Avg TELE":wavg("TELE Pts"), "Avg END":wavg("END Pts"),
      "Wgt TOTAL":wavg("TOTAL"), "Avg FOUL to Opp":wavg("Opp Pts From Fouls")
    });
  }
  rows.sort((a,b)=>asInt(a.Team)-asInt(b.Team));
  return rows;
}
function renderTableFromObjects(tblId, rows, headers){
  const tb = qs(`#${tblId} tbody`); tb.innerHTML="";
  rows.forEach(r=>{
    const cols = headers.map(h => (h in r) ? (typeof r[h]==="number" ? Number(r[h]).toFixed(2) : r[h]) : "");
    tb.appendChild(mkRow(cols));
  });
}

/* Predictor & Planner (unchanged) */
function indexByTeam(rows){ const m = new Map(); rows.forEach(r => m.set(asInt(r.Team), r)); return m; }
function fetchAllianceTeams(){
  const r = [qs("#r1").value, qs("#r2").value, qs("#r3").value].map(asInt).filter(Boolean);
  const b = [qs("#b1").value, qs("#b2").value, qs("#b3").value].map(asInt).filter(Boolean);
  return {r,b};
}
function sumTeams(rowsIndex, teams, field){
  return sum(teams.map(t => asNum(rowsIndex.get(t)?.[field] || 0)));
}
function coralLevelTotals(rowsIndex, teams){
  const sumField = (f)=>sum(teams.map(t => asNum(rowsIndex.get(t)?.[f]||0)));
  return {
    L1: sumField("AUTO L1")+sumField("TELE L1"),
    L2: sumField("AUTO L2")+sumField("TELE L2"),
    L3: sumField("AUTO L3")+sumField("TELE L3"),
    L4: sumField("AUTO L4")+sumField("TELE L4"),
  };
}
function reliabilityFactorForTeam(team){ return reliabilityFactor(team); }
function computePredictions(){
  const {r,b} = fetchAllianceTeams();
  const simple = computeSimpleAverages(); const sm = indexByTeam(simple);
  const weighted = computeWeightedAverages(state.config.decay); const wm = indexByTeam(weighted);

  qs("#predRedSimple").textContent = sumTeams(sm, r, "Avg TOTAL").toFixed(1);
  qs("#predBlueSimple").textContent = sumTeams(sm, b, "Avg TOTAL").toFixed(1);
  qs("#predRedWeighted").textContent = sumTeams(wm, r, "Wgt TOTAL").toFixed(1);
  qs("#predBlueWeighted").textContent = sumTeams(wm, b, "Wgt TOTAL").toFixed(1);

  const W = state.weights;
  function customFor(team, m){
    const A = asNum(m.get(team)?.["Avg AUTO"]||0);
    const T = asNum(m.get(team)?.["Avg TELE"]||0);
    const E = asNum(m.get(team)?.["Avg END"]||0);
    const F = asNum(m.get(team)?.["Avg FOUL to Opp"]||0);
    const rf = reliabilityFactorForTeam(team);
    return (A*W.wAuto + T*W.wTele + E*W.wEnd - F*W.wFoul) * rf;
    }
  const rC = r.reduce((acc,t)=>acc+customFor(t, sm), 0);
  const bC = b.reduce((acc,t)=>acc+customFor(t, sm), 0);
  qs("#predRedCustom").textContent = rC.toFixed(1);
  qs("#predBlueCustom").textContent = bC.toFixed(1);

  // RP heuristics
  const leaveSum = sumTeams(sm, r, "AUTO Leave");
  const autoCoralAny = (sumTeams(sm, r, "AUTO L1")+sumTeams(sm, r, "AUTO L2")
                      +sumTeams(sm, r, "AUTO L3")+sumTeams(sm, r, "AUTO L4")) > 0 ? "Yes" : "No";
  qs("#rpAuto").textContent = (leaveSum >= 2.5 && autoCoralAny==="Yes") ? "Likely" : "Unlikely/Maybe";

  const C = state.config.rp; const L = coralLevelTotals(sm, r);
  const levels = (L.L1>=C.coralPerLevel) + (L.L2>=C.coralPerLevel) + (L.L3>=C.coralPerLevel) + (L.L4>=C.coralPerLevel);
  qs("#rpCoral").textContent = (levels>=C.levels) ? "Likely (no Coop)" : (levels>=C.levelsCoop ? "Maybe (with Coop)" : "Unlikely");

  const endPts = 2*sumTeams(sm, r, "END Park") + 6*sumTeams(sm, r, "END Shallow") + 12*sumTeams(sm, r, "END Deep");
  qs("#rpBarge").textContent = (endPts >= C.bargePts) ? "Likely" : "Unlikely/Maybe";

  const redProc = sumTeams(sm, r, "AUTO AlgProc")+sumTeams(sm, r, "TELE AlgProc");
  const blueProc = sumTeams(sm, b, "AUTO AlgProc")+sumTeams(sm, b, "TELE AlgProc");
  qs("#rpCoop").textContent = (redProc>=2 && blueProc>=2) ? "Likely" : "Unlikely/Depends";
}

/* Planner (unchanged) */
function renderPlanner(){
  const our = asInt(state.config.ourTeam);
  const ours = state.scheduleExpanded.filter(r=>asInt(r.team)===our);
  const ourMatches = uniq(ours.map(r=>asInt(r.match))).sort((a,b)=>a-b);

  // Our Matches table
  const tb = qs("#ourMatchesTbl tbody"); tb.innerHTML="";
  for (const m of ourMatches){
    const rows = state.scheduleExpanded.filter(r=>asInt(r.match)===m);
    const ourRow = rows.find(r=>asInt(r.team)===our);
    const ourAlliance = ourRow?.alliance || "";
    const partners = rows.filter(r=>r.alliance===ourAlliance && asInt(r.team)!==our).map(r=>r.team).join(", ");
    const opps = rows.filter(r=>r.alliance!==ourAlliance).map(r=>r.team).join(", ");
    const time = (state.schedule.find(x=>asInt(x.match)===m && x.comp===ourRow?.comp)||{}).time || (state.schedule.find(x=>asInt(x.match)===m)||{}).time || "";
    tb.appendChild(mkRow([m, ourAlliance, partners, opps, time]));
  }

  // Priority teams we face + first shared match + scouted rows count
  const teamsWeFace = uniq(
    ourMatches.flatMap(m => state.scheduleExpanded.filter(r=>asInt(r.match)===m && asInt(r.team)!==our).map(r=>asInt(r.team)))
  ).sort((a,b)=>a-b);
  const tb2 = qs("#priorityTbl tbody"); tb2.innerHTML="";
  for (const t of teamsWeFace){
    const firstShared = ourMatches.find(m => state.scheduleExpanded.some(r=>asInt(r.match)===m && asInt(r.team)===t));
    const rowAtMatch = state.scheduleExpanded.find(r=>asInt(r.match)===firstShared && asInt(r.team)===t);
    const ourRowAtMatch = state.scheduleExpanded.find(r=>asInt(r.match)===firstShared && asInt(r.team)===our);
    const role = (rowAtMatch?.alliance === ourRowAtMatch?.alliance) ? "Partner" : "Opponent";
    const scoutedRows = state.raw.filter(r=>asInt(r.Team)===t && asNum(r["TOTAL"])>0).length;
    const chip = scoutedRows>0 ? `<span class="pill ok">${scoutedRows}</span>` : `<span class="pill bad">0</span>`;
    tb2.appendChild(mkRow([t, firstShared??"", role, chip]));
  }

  // Opponents by our match (coverage gaps)
  const tb3 = qs("#oppChecklistTbl tbody"); tb3.innerHTML="";
  for (const m of ourMatches){
    const rows = state.scheduleExpanded.filter(r=>asInt(r.match)===m);
    const ourRow = rows.find(r=>asInt(r.team)===our);
    const opps = rows.filter(r=>r.alliance!==ourRow?.alliance).map(r=>asInt(r.team));
    const gaps = opps.filter(t => state.raw.filter(r=>asInt(r.Team)===t && asNum(r["TOTAL"])>0).length===0);
    const gapCell = gaps.length? `<span class="pill warn mono">${gaps.join(", ")}</span>` : `<span class="pill ok">none</span>`;
    tb3.appendChild(mkRow([m, opps[0]||"", opps[1]||"", opps[2]||"", gapCell]));
  }

  // OTHER MATCHES TO SCOUT sorted QM → SF → F
  (function buildOtherMatchesToScout(){
    const tb = qs("#otherMatchesTbl tbody"); if (!tb) return;
    tb.innerHTML = "";
    if (!our) return;

    const ourMatchSet = new Set(ourMatches);
    const opponentsSet = new Set();
    for (const m of ourMatches) {
      const rows = state.scheduleExpanded.filter(r => asInt(r.match) === m);
      const ourRow = rows.find(r => asInt(r.team) === our);
      if (!ourRow) continue;
      for (const r of rows) {
        if (r.alliance !== ourRow.alliance) opponentsSet.add(asInt(r.team));
      }
    }

    const hi = (t) => opponentsSet.has(asInt(t))
      ? `<span class="pill bad mono">${t}</span>`
      : `<span class="mono">${t}</span>`;

    const candidates = [];
    for (const s of state.schedule) {
      if (ourMatchSet.has(asInt(s.match))) continue;
      const allTeams = [...s.red, ...s.blue].map(asInt);
      const important = allTeams.filter(t => opponentsSet.has(t));
      if (important.length === 0) continue;

      candidates.push({
        comp: s.comp || "",
        set: asInt(s.set || 0),
        match: asInt(s.match),
        time: s.time || "",
        count: important.length,
        teamsCell:
          `R: ${hi(s.red[0])}, ${hi(s.red[1])}, ${hi(s.red[2])} &nbsp; | &nbsp; ` +
          `B: ${hi(s.blue[0])}, ${hi(s.blue[1])}, ${hi(s.blue[2])}`,
        importantCell: important.map(t => `<span class="pill warn mono">${t}</span>`).join(" ")
      });
    }

    const compOrder = { qm:0, sf:1, f:2 };
    candidates.sort((a,b)=>{
      const ra = compOrder[(a.comp||"").toLowerCase()] ?? 99;
      const rb = compOrder[(b.comp||"").toLowerCase()] ?? 99;
      if (ra !== rb) return ra - rb;
      if (a.set !== b.set) return a.set - b.set;
      return a.match - b.match;
    });

    for (const c of candidates) {
      const label = `${(c.comp||"").toUpperCase()} ${c.match}`;
      tb.appendChild(mkRow([label, c.teamsCell, c.importantCell, String(c.count), c.time]));
    }
  })();
}

function renderSchedulePicklist(){
  const sel=qs("#pickMatch");
  const seen=new Set();
  sel.innerHTML='<option value="">—</option>';
  for (const s of state.schedule){
    if (s.comp?.toLowerCase().startsWith("qm") && !seen.has(s.match)){
      const o=document.createElement("option");
      o.value=String(s.match); o.textContent=s.match;
      sel.appendChild(o); seen.add(s.match);
    }
  }
}
qs("#exportSchedule").onclick = ()=>{
  const rows = state.schedule.map(m => ({
    Event:m.event, CompLevel:m.comp, Set:m.set, Match:m.match, Time:m.time,
    Red1:m.red[0], Red2:m.red[1], Red3:m.red[2], Blue1:m.blue[0], Blue2:m.blue[1], Blue3:m.blue[2]
  }));
  download("schedule.csv", toCSV(rows));
};
qs("#exportRaw").onclick = ()=> download("raw_data.csv", toCSV(state.raw));
qs("#exportPit").onclick = ()=> download("pit_scouting.csv", toCSV(state.pit));
qs("#exportJson").onclick = ()=> download("reefscape_scouter.json", JSON.stringify(state, null, 2));
qs("#importFile").onchange = (e)=>{
  const f = e.target.files?.[0]; if(!f) return;
  const fr = new FileReader();
  fr.onload = ()=>{
    try{
      const obj = JSON.parse(fr.result);
      Object.assign(state, obj);
      saveAll(); boot();
    }catch(err){ alert("Invalid JSON"); }
  };
  fr.readAsText(f);
};
qs("#clearStorage").onclick = ()=>{ if(confirm("Clear localStorage & reset?")){ localStorage.removeItem(LS_KEY); location.reload(); } };
qs("#saveCfg").onclick = saveSettings;
qs("#saveWeights").onclick = saveWeights;
qs("#parseSchedule").onclick = ()=>{
  const txt = qs("#schedulePaste").value;
  state.schedule = parseScheduleText(txt);
  onScheduleUpdated();
};
qs("#clearSchedule").onclick = ()=>{
  state.schedule = []; state.scheduleExpanded = [];
  renderSchedule(); renderSchedExpanded(); renderSchedulePicklist(); renderPlanner(); renderRaw(); saveAll();
};
qs("#recompute").onclick = ()=> recomputeEverything();
qs("#pickMatch").onchange = ()=>{
  const m = asInt(qs("#pickMatch").value);
  if(!m) return;
  const s = state.schedule.find(x=>x.comp?.toLowerCase().startsWith("qm") && asInt(x.match)===m);
  if(!s) return;
  qs("#r1").value=s.red[0]||""; qs("#r2").value=s.red[1]||""; qs("#r3").value=s.red[2]||"";
  qs("#b1").value=s.blue[0]||""; qs("#b2").value=s.blue[1]||""; qs("#b3").value=s.blue[2]||"";
  computePredictions();
};
["#r1","#r2","#r3","#b1","#b2","#b3"].forEach(id=> qs(id).addEventListener("input", computePredictions));

/* Recompute */
function recomputeEverything(){
  state.raw.forEach(r=>{
    // sanitize all numeric fields (no negatives)
    Object.keys(r).forEach(k=> ensureNoNegative(r,k));
    clampAllCaps(r, ""); // run global clamp
    computePointsForRow(r);
  });
  const simple = computeSimpleAverages(); renderTableFromObjects("avgTbl", simple, AVG_HEADERS);
  const weighted = computeWeightedAverages(state.config.decay);
  renderTableFromObjects("wavgTbl", weighted, AVG_HEADERS.map(h=> h==="Avg TOTAL"?"Wgt TOTAL":h.replace("Avg ","Wgt ")));
  renderPlanner();
  computePredictions();
  saveAll();
}

/* ======== Paper sheets (print) ======== */
function openPrintSheets(){
  // One generic blank sheet per page. You can print many copies.
  const w = window.open("", "_blank");
  const today = new Date().toLocaleString();
  const html = `<!DOCTYPE html><html><head><meta charset="utf-8">
  <title>REEFSCAPE Paper Sheet</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial; margin:24px;}
    h2{margin:0 0 8px 0}
    .meta{display:grid; grid-template-columns:repeat(4,1fr); gap:8px; margin-bottom:10px}
    .box{border:1px solid #000; padding:8px; min-height:28px}
    table{width:100%; border-collapse:collapse; margin-top:6px}
    th,td{border:1px solid #000; padding:6px; font-size:12px}
    .small{font-size:11px;color:#333}
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:8px}
    .foot{margin-top:8px; font-size:11px}
    @media print{ .pagebreak{page-break-after:always;} }
  </style>
  </head><body>
  <h2>REEFSCAPE 2025 Paper Scouting Sheet</h2>
  <div class="small">Print date: ${today}</div>

  <div class="meta">
    <div><b>Event</b><div class="box">&nbsp;</div></div>
    <div><b>Comp (QM/SF/F)</b><div class="box">&nbsp;</div></div>
    <div><b>Match #</b><div class="box">&nbsp;</div></div>
    <div><b>Team #</b><div class="box">&nbsp;</div></div>
    <div><b>Alliance (Red/Blue)</b><div class="box">&nbsp;</div></div>
    <div><b>Scout Name</b><div class="box">&nbsp;</div></div>
    <div><b>Robot Notes</b><div class="box" style="height:48px">&nbsp;</div></div>
    <div><b>Field Notes</b><div class="box" style="height:48px">&nbsp;</div></div>
  </div>

  <div class="grid2">
    <div>
      <b>Auto</b>
      <table>
        <tr><th>Leave (Y/N)</th><th>L1</th><th>L2</th><th>L3</th><th>L4</th><th>Alg→Proc</th><th>Alg→Net</th></tr>
        <tr><td class="box" style="text-align:center"></td>
            <td class="box"></td><td class="box"></td><td class="box"></td><td class="box"></td><td class="box"></td><td class="box"></td></tr>
      </table>
      <div class="small">Coral L1 unlimited; L2/L3/L4 ≤ 12 (combined Auto+Tele); Algae total ≤ 9.</div>
    </div>
    <div>
      <b>Teleop</b>
      <table>
        <tr><th>L1</th><th>L2</th><th>L3</th><th>L4</th><th>Alg→Proc</th><th>Alg→Net</th></tr>
        <tr><td class="box"></td><td class="box"></td><td class="box"></td><td class="box"></td><td class="box"></td><td class="box"></td></tr>
      </table>
    </div>
  </div>

  <b>Endgame</b>
  <table>
    <tr><th>Park</th><th>Shallow Climb</th><th>Deep Climb</th><th>Fouls Minor</th><th>Fouls Major</th></tr>
    <tr><td class="box"></td><td class="box"></td><td class="box"></td><td class="box"></td><td class="box"></td></tr>
  </table>

  <div class="foot">Write numbers clearly in boxes (0+). For Leave/Park/Climbs, write "Y" or leave blank.</div>

  <div class="pagebreak"></div>
  </body></html>`;
  w.document.write(html);
  w.document.close();
}

/* ======== Camera Scan w/ OCR (Tesseract) ======== */
let mediaStream = null;
async function openScanner(){
  const modal = qs("#scanModal");
  modal.classList.add("open");
  const video = qs("#scanVideo");
  try{
    mediaStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio:false });
    video.srcObject = mediaStream;
  }catch(err){
    logScan(`Camera error: ${err.message}`);
  }
}
function closeScanner(){
  const modal = qs("#scanModal"); modal.classList.remove("open");
  const video = qs("#scanVideo");
  if (video && video.srcObject){
    video.pause();
    const tracks = video.srcObject.getTracks();
    tracks.forEach(t => t.stop());
    video.srcObject = null;
  }
}
function logScan(msg){
  const el = qs("#scanLog");
  el.innerHTML = `<div>${(new Date()).toLocaleTimeString()} — ${msg}</div>` + el.innerHTML;
}

async function captureAndOCR(){
  const video = qs("#scanVideo");
  if (!video.videoWidth){ logScan("Video not ready yet."); return; }
  // Draw current frame to canvas
  const canvas = document.createElement("canvas");
  const scale = Math.min(1280 / video.videoWidth, 720 / video.videoHeight, 1);
  canvas.width = Math.floor(video.videoWidth * scale);
  canvas.height = Math.floor(video.videoHeight * scale);
  const ctx = canvas.getContext("2d");
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  logScan("Running OCR… (~a few seconds)");

  try{
    const { data:{ text } } = await Tesseract.recognize(canvas, 'eng', { 
      tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz:/-() \n' 
    });
    logScan(`<pre>${text.replace(/[<>&]/g, c=>({ '<':'&lt;','>':'&gt;','&':'&amp;' }[c]))}</pre>`);
    const row = parseScannedTextToRow(text);
    if (!row){
      logScan("Could not parse required fields (Comp/Match/Team).");
      return;
    }
    state.raw.push(row);
    renderRaw();
    recomputeEverything();
    saveAll();
    logScan(`<span class="pill ok">Added row for Team ${row.Team} in ${row.Comp} ${row.Match}</span>`);
  }catch(err){
    logScan(`OCR error: ${err.message}`);
  }
}

// Very simple parser; it matches labels as printed on the sheet.
function parseScannedTextToRow(text){
  const norm = (text||"").replace(/\r/g,"").replace(/[^\S\n]+/g,' ').trim();
  function find(re, def=null){ const m = norm.match(re); return m? m[1] : def; }

  const Event = find(/Event\s*([A-Za-z0-9_-]+)/i, "");
  const Comp = (find(/Comp\s*\(?\s*(QM|SF|F)\s*\)?/i, "")||"").toUpperCase();
  const Match = asInt(find(/Match\s*#?\s*(\d{1,4})/i, 0));
  const Team = asInt(find(/Team\s*#?\s*(\d{1,6})/i, 0));
  const Alliance = ((find(/Alliance\s*\(?\s*(Red|Blue)\s*\)?/i, "")||"").toLowerCase()==="red")?"Red":(((find(/Alliance\s*\(?\s*(Red|Blue)\s*\)?/i,"")||"").toLowerCase()==="blue")?"Blue":"");

  if (!Comp || !Match || !Team) return null;

  const YN = s => /y(es)?/i.test(s||"") ? 1 : 0;
  const leave = YN(find(/Leave\s*\(?.*?\)?\s*([Yy][Ee]?[Ss]?)/i, "")); // "Y" count as 1

  // helper to get numbers after label; if missing => 0
  const numAfter = (label) => asInt(find(new RegExp(label+"\\s*:?\\s*(-?\\d+)", "i"), 0));

  const aL1 = Math.max(0, numAfter("Auto\\s*L1|L1\\s*Auto"));
  const aL2 = Math.max(0, numAfter("Auto\\s*L2|L2\\s*Auto"));
  const aL3 = Math.max(0, numAfter("Auto\\s*L3|L3\\s*Auto"));
  const aL4 = Math.max(0, numAfter("Auto\\s*L4|L4\\s*Auto"));
  const aP  = Math.max(0, numAfter("Alg\\s*→?\\s*Proc\\s*Auto|Auto\\s*Alg\\s*Proc|Auto\\s*Processor"));
  const aN  = Math.max(0, numAfter("Alg\\s*→?\\s*Net\\s*Auto|Auto\\s*Alg\\s*Net"));

  const tL1 = Math.max(0, numAfter("Tele\\s*L1|L1\\s*Tele"));
  const tL2 = Math.max(0, numAfter("Tele\\s*L2|L2\\s*Tele"));
  const tL3 = Math.max(0, numAfter("Tele\\s*L3|L3\\s*Tele"));
  const tL4 = Math.max(0, numAfter("Tele\\s*L4|L4\\s*Tele"));
  const tP  = Math.max(0, numAfter("Alg\\s*→?\\s*Proc\\s*Tele|Tele\\s*Alg\\s*Proc|Tele\\s*Processor"));
  const tN  = Math.max(0, numAfter("Alg\\s*→?\\s*Net\\s*Tele|Tele\\s*Alg\\s*Net"));

  const park = YN(find(/Park\s*([Yy][Ee]?[Ss]?)/i, ""));
  const sh   = YN(find(/Shallow\s*(Climb)?\s*([Yy][Ee]?[Ss]?)/i, ""));
  const deep = YN(find(/Deep\s*(Climb)?\s*([Yy][Ee]?[Ss]?)/i, ""));
  const fMin = Math.max(0, asInt(find(/Fouls?\s*Minor\s*:?\\s*(-?\\d+)/i, 0)));
  const fMaj = Math.max(0, asInt(find(/Fouls?\s*Major\s*:?\\s*(-?\\d+)/i, 0)));

  const r = newManualRawRow();
  r.Event = Event; r.Comp = Comp; r.Match = Match; r.Team = Team; r.Alliance = Alliance;
  r["AUTO Leave"]=leave;
  r["AUTO: L1"]=aL1; r["AUTO: L2"]=aL2; r["AUTO: L3"]=aL3; r["AUTO: L4"]=aL4;
  r["AUTO: Alg→Proc"]=aP; r["AUTO: Alg→Net"]=aN;
  r["TELE: L1"]=tL1; r["TELE: L2"]=tL2; r["TELE: L3"]=tL3; r["TELE: L4"]=tL4;
  r["TELE: Alg→Proc"]=tP; r["TELE: Alg→Net"]=tN;
  r["END: Park"]=park; r["END: Shallow"]=sh; r["END: Deep"]=deep;
  r["Fouls: Minor"]=fMin; r["Fouls: Major"]=fMaj;

  // Enforce caps & compute
  clampAllCaps(r, "");
  computePointsForRow(r);
  return r;
}

/* Wire up print+scan buttons */
qs("#printSheets").onclick = openPrintSheets;
qs("#scanSheets").onclick = openScanner;
qs("#closeScan").onclick = closeScanner;
qs("#captureFrame").onclick = captureAndOCR;

/* Boot */
function renderAvgHeadersWrap(){ renderAvgHeaders(); }
function renderRawHeadersAndBodyWrap(){ renderRawHeadersAndBody(); }
function boot(){
  loadAll();
  renderRules();
  bindSettings();
  renderSchedExpanded();
  renderSchedule();
  renderSchedulePicklist();
  renderAvgHeadersWrap();
  renderPit();
  renderRawHeadersAndBodyWrap();
  recomputeEverything();
}
boot();
</script>
</body>
</html>
